%!PS-Adobe-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: figura_3.dvi
%%CreationDate: Wed Aug 15 17:55:49 2018
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 202 108
%%DocumentFonts: SFRM1000 CMMI10
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips figura_3.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2018.08.15:1755
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-circ.pro 0 0
%!
% $Id: pst-circ.pro 3 2007-12-23 16:23:22Z herbert $
%
% PostScript prologue for pst-circ.tex.
% version 0.01 2007-03-23 (hv)
% For distribution, see pstricks.tex.
%
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def 
/ZeroEq { abs 1E-10 lt } bind def /EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub } bind def
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
  { pop pop pop 0 0 }
  {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
  }
  ifelse  } bind def
% END pst-circ.pro

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 882 2014-02-01 13:12:37Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.32 / 2014-02-01  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
    coorType 5 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees 
      /x2D x z 0.5 mul Alpha cos mul add def
      /y2D y z 0.5 mul Alpha sin mul add def 
      exit } if
    coorType 6 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees and z into the front
      /x2D y x -0.559 mul Alpha cos mul add def
      /y2D z x -0.559 mul Alpha sin mul add def 
      exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumire
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on dcrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilit
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale  la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: pst-solides3d.pro 0 0
%!
% PostScript prologue for pst-solides3d.tex.
% Version 4.30, 2015/12/17
%
%% COPYRIGHT 2009-2013 by Jean-Paul Vignault
%% opacity changes by Herbert Voss
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN
%% archives in directory macros/latex/base/lppl.txt.
%
/SolidesDict 100 dict def
/SolidesbisDict 100 dict def
SolidesDict begin

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les variables globales gerees par PSTricks %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les lignes dessous sont a decommenter si l on veut utiliser le
%% %% fichier solides.pro independamment du package PSTricks
%% /Dobs 20 def
%% /THETA 20 def
%% /PHI 50 def
%% /Decran 30 def
%% /XpointVue {Dobs Cos1Cos2 mul} def
%% /YpointVue {Dobs Sin1Cos2 mul} def
%% /ZpointVue {Dobs Sin2 mul} def
%% /xunit 28.14 def
%% /solidhollow false def
%% /solidbiface false def
%% /xunit 28.45 def
%% /tracelignedeniveau? true def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% /solidgrid true def
/aretescachees true def
/defaultsolidmode 2 def
%
/Stroke { strokeopacity .setopacityalpha stroke } def
/Fill { fillopacity .setopacityalpha fill } def
%
%% variables globales specifiques a PSTricks
%% /activationgestioncouleurs true def
/xmin -10 def
/xmax 10 def
/ymin -10 def
/ymax 10 def

/fillstyle {} def
/startest false def
/cm {} def
/cm_1 {} def
/yunit {xunit} def
/angle_repere 90 def

/hadjust 2.5 def
/vadjust 2.5 def
/pl@n-en-cours false def

/pointilles { [6.25 3.75] 1.25 setdash } def
/stockcurrentcpath {} def
/newarrowpath {} def
/chaine 15 string def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% choix d une fonte accentuee pour le .ps %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/ReEncode { exch findfont
dup length dict begin { 1 index /FID eq {pop pop} {def} ifelse
}forall /Encoding ISOLatin1Encoding def currentdict end definefont
pop }bind def
/Font /Times-Roman /ISOfont ReEncode /ISOfont def
%Font findfont 10 scalefont setfont

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% extrait de color.pro pour pouvoir recuperer ses couleurs %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GreenYellow{0.15 0 0.69 0 setcmykcolor}def
/Yellow{0 0 1 0 setcmykcolor}def
/Goldenrod{0 0.10 0.84 0 setcmykcolor}def
/Dandelion{0 0.29 0.84 0 setcmykcolor}def
/Apricotq{0 0.32 0.52 0 setcmykcolor}def
/Peach{0 0.50 0.70 0 setcmykcolor}def
/Melon{0 0.46 0.50 0 setcmykcolor}def
/YellowOrange{0 0.42 1 0 setcmykcolor}def
/Orange{0 0.61 0.87 0 setcmykcolor}def
/BurntOrange{0 0.51 1 0 setcmykcolor}def
/Bittersweet{0 0.75 1 0.24 setcmykcolor}def
/RedOrange{0 0.77 0.87 0 setcmykcolor}def
/Mahogany{0 0.85 0.87 0.35 setcmykcolor}def
/Maroon{0 0.87 0.68 0.32 setcmykcolor}def
/BrickRed{0 0.89 0.94 0.28 setcmykcolor}def
/Red{0 1 1 0 setcmykcolor}def
/OrangeRed{0 1 0.50 0 setcmykcolor}def
/RubineRed{0 1 0.13 0 setcmykcolor}def
/WildStrawberry{0 0.96 0.39 0 setcmykcolor}def
/Salmon{0 0.53 0.38 0 setcmykcolor}def
/CarnationPink{0 0.63 0 0 setcmykcolor}def
/Magenta{0 1 0 0 setcmykcolor}def
/VioletRed{0 0.81 0 0 setcmykcolor}def
/Rhodamine{0 0.82 0 0 setcmykcolor}def
/Mulberry{0.34 0.90 0 0.02 setcmykcolor}def
/RedViolet{0.07 0.90 0 0.34 setcmykcolor}def
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}def
/Lavender{0 0.48 0 0 setcmykcolor}def
/Thistle{0.12 0.59 0 0 setcmykcolor}def
/Orchid{0.32 0.64 0 0 setcmykcolor}def
/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}def
/Purple{0.45 0.86 0 0 setcmykcolor}def
/Plum{0.50 1 0 0 setcmykcolor}def
/Violet{0.79 0.88 0 0 setcmykcolor}def
/RoyalPurple{0.75 0.90 0 0 setcmykcolor}def
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}def
/Periwinkle{0.57 0.55 0 0 setcmykcolor}def
/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}def
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}def
/MidnightBlue{0.98 0.13 0 0.43 setcmykcolor}def
/NavyBlue{0.94 0.54 0 0 setcmykcolor}def
/RoyalBlue{1 0.50 0 0 setcmykcolor}def
/Blue{1 1 0 0 setcmykcolor}def
/Cerulean{0.94 0.11 0 0 setcmykcolor}def
/Cyan{1 0 0 0 setcmykcolor}def
/ProcessBlue{0.96 0 0 0 setcmykcolor}def
/SkyBlue{0.62 0 0.12 0 setcmykcolor}def
/Turquoise{0.85 0 0.20 0 setcmykcolor}def
/TealBlue{0.86 0 0.34 0.02 setcmykcolor}def
/Aquamarine{0.82 0 0.30 0 setcmykcolor}def
/BlueGreen{0.85 0 0.33 0 setcmykcolor}def
/Emerald{1 0 0.50 0 setcmykcolor}def
/JungleGreen{0.99 0 0.52 0 setcmykcolor}def
/SeaGreen{0.69 0 0.50 0 setcmykcolor}def
/Green{1 0 1 0 setcmykcolor}def
/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}def
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}def
/LimeGreen{0.50 0 1 0 setcmykcolor}def
/YellowGreen{0.44 0 0.74 0 setcmykcolor}def
/SpringGreen{0.26 0 0.76 0 setcmykcolor}def
/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}def
/RawSienna{0 0.72 1 0.45 setcmykcolor}def
/Sepia{0 0.83 1 0.70 setcmykcolor}def
/Brown{0 0.81 1 0.60 setcmykcolor}def
/Tan{0.14 0.42 0.56 0 setcmykcolor}def
/Gray{0 0 0 0.50 setcmykcolor}def
/Black{0 0 0 1 setcmykcolor}def
/White{0 0 0 0 setcmykcolor}def
%% fin de l extrait color.pro

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             autres couleurs                        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/bleu {0 0 1 setrgbcolor} def
/rouge {1 0 0 setrgbcolor} def
/vert {0 .5 0 setrgbcolor} def
/gris {.4 .4 .4 setrgbcolor} def
/jaune {1 1 0 setrgbcolor} def
/noir {0 0 0 setrgbcolor} def
/blanc {1 1 1 setrgbcolor} def
/orange {1 .65 0 setrgbcolor} def
/rose {1 .01 .58  setrgbcolor} def
/cyan {1 0 0 0 setcmykcolor} def
/magenta {0 1 0 0 setcmykcolor} def

/blue /bleu load def
/red /rouge load def
/green /vert load def
/gray /gris load def
/yellow /jaune load def
/black /noir load def
/white /blanc load def
%/orange {1 .65 0 setrgbcolor} def
/pink /rose load def
%/cyan {1 0 0 0 setcmykcolor} def
%/magenta {0 1 0 0 setcmykcolor} def




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             definition du point de vue             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pour la 3D conventionnelle
%% Dony : graphisme scientifique : page 187
%% Editeur : Masson

%% calcul des coefficients de la matrice
%% de transformation
/Sin1 {THETA sin} def
/Sin2 {PHI sin} def
/Cos1 {THETA cos} def
/Cos2 {PHI cos} def
/Cos1Sin2 {Cos1 Sin2 mul} def
/Sin1Sin2 {Sin1 Sin2 mul} def
/Cos1Cos2 {Cos1 Cos2 mul} def
/Sin1Cos2 {Sin1 Cos2 mul} def

/3dto2d {
6 dict begin
   /Zcote exch def
   /Yordonnee exch def
   /Xabscisse exch def
   /xObservateur
      Xabscisse Sin1 mul neg Yordonnee Cos1 mul add
   def
   /yObservateur
      Xabscisse Cos1Sin2 mul neg Yordonnee Sin1Sin2 mul sub Zcote Cos2
      mul add
   def
   /zObservateur
      Xabscisse neg Cos1Cos2 mul Yordonnee Sin1Cos2 mul sub Zcote Sin2
      mul sub Dobs add
   def
   %% maintenant on depose les resultats sur la pile
   Decran xObservateur mul zObservateur div cm
   Decran yObservateur mul zObservateur div cm
end
} def

/getpointVue {
   XpointVue
   YpointVue
   ZpointVue
} def

/GetCamPos {
   getpointVue
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         jps modifie pour PSTricks                  %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/solid {continu} def
/dashed {pointilles} def
/dotted { [2] 0 setdash } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             geometrie basique                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% syntaxe~: [x1 y1 ... xn yn] ligne
/ligne {
gsave
   newpath
      dup 0 getp smoveto
      ligne_
      starfill
   Stroke
grestore
} def

%% syntaxe~: [x1 y1 ... xn yn] ligne_
/ligne_ {
   reversep
   aload length 2 idiv
   {
      slineto
   } repeat
} def

%% syntaxe~: [x1 y1 ... xn yn] polygone
/polygone* {
1 dict begin
   /startest {true} def
   polygone
end
} def

/polygone_ {
   newpath
      aload length 2 idiv
      3 copy pop
      smoveto
      {
         slineto
      } repeat
   closepath
} def

/polygone {
   gsave
      polygone_
      starfill
      currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
} def

%% syntaxe : x y point
/point {
gsave
   1 setlinecap
   newpath
      smoveto
      0 0 rlineto
      5 setlinewidth
   Stroke
grestore
} def

/point_ {
   1 setlinecap
   5 setlinewidth
      smoveto
      0 0 rlineto
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%          insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              le repere jps                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### AAAopacity ###

%% les parametres pour la gestion de la transparence

/setstrokeopacity { /strokeopacity exch def } def
/setfillopacity { /fillopacity exch def } def

%% d apres un code de Jean-Michel Sarlat
%% http://melusine.eu.org/syracuse/swf/pdf2swf/setdash/
%% Mise en reserve de la procedure stroke originelle.
/sysstroke {systemdict /stroke get exec} def
/sysfill {systemdict /fill get exec} def
/sysatan {systemdict /atan get exec} def
/atan {2 copy 0 0 eqp {pop pop 0} {sysatan} ifelse} def
% Mise en place de la nouvelle procedure
/Stroke { /strokeopacity where { /strokeopacity get }{ 1 } ifelse
   .setopacityalpha sysstroke
} def
/Fill { /fillopacity where { /fillopacity get }{ 1 } ifelse
   .setopacityalpha sysfill
} def

%%%%% ### AAAscale ###
%%%%%%%%%%%%%%%% les deplacements a l echelle %%%%%%%%%%%%%%%%%%%

 /v@ct_I {xunit 0} def
 /v@ct_J {angle_repere cos yunit mul angle_repere sin yunit mul} def

/xscale {} def
/yscale {} def

/xscale-1 {} def
/yscale-1 {} def

/gtransform {} def
/gtransform-1 {} def

/jtoppoint {
2 dict begin
   gtransform
   /y exch yscale def
   /x exch xscale def
   v@ct_I x mulv
   v@ct_J y mulv
   addv
end
} def

/rptojpoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
   ptojpoint
} def

/rptoppoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
} def

/ptojpoint {
4 dict begin
   /Y exch yscale-1 def
   /X exch xscale-1 def
   /y Y yunit angle_repere sin mul div def
   /x X y yunit mul angle_repere cos mul sub xunit div def
   x y
   gtransform-1
end
} def

/smoveto {
   jtoppoint
   moveto
} def

/srmoveto {
   jtoppoint
   rmoveto
} def

/slineto {
   jtoppoint
   lineto
} def

/srlineto {
   jtoppoint
   rlineto
} def

/stranslate {
   jtoppoint
   translate
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%            methodes numeriques                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solve2nddegre ###
%% syntaxe : a b c solve2nddegre --> x1 x2
/solve2nddegre {
5 dict begin
   /@c exch def
   /@b exch def
   /@a exch def
   /delt@ @b dup mul 4 @a mul @c mul sub def
   @b neg delt@ sqrt sub 2 @a mul div
   @b neg delt@ sqrt add 2 @a mul div
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  la 2D                             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  points                            %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### tripointangle ###
%% syntaxe : A B C tripointangle --> angle ABC
/tripointangle {
9 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   B C angle
   B A angle
   sub
end   
} def

%%%%% ### angle ###
%% syntaxe : A B angle
%% --> num, l'angle defini par le vecteur AB dans le repere orthonorme jps 
/angle {
   vecteur exch atan
   dup 180 gt 
      {360 sub}
   if
} def

%% syntaxe : A B pangle
%% --> num, l'angle defini par le vecteur AB dans le repere postscript
/pangle {
   jtoppoint exchp jtoppoint exchp vecteur exch atan
   dup 180 gt 
	 {360 sub}
   if
} def

%%%%% ### setxrange ###
/setxrange {
   /xmax exch def
   /xmin exch def
} def

%%%%% ### setyrange ###
/setyrange {
   /ymax exch def
   /ymin exch def
} def

%%%%% ### defpoint ###
%% syntaxe : xA yA /A defpoint
/defpoint {
1 dict begin
   /t@mp@r@ire exch def
   [ 3 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### milieu ###
%% syntaxe~: A B milieu 
/milieu {  
                %% xA yA xB yB
   3 -1 roll    %% xA xB yB yA 
   add 2 div    %% xA xB yM
   3 1 roll     %% yM xA xB 
   add 2 div    %% yM xM
   exch
} def

%%%%% ### parallelopoint ###
%% syntaxe : A B C parallelopoint --> point D, tel que ABCD parallelogramme
/parallelopoint {
11 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /d1 {A B C paral} def
   /d2 {B C A paral} def
   d1 d2 interdroite
end
} def

%%%%% ### translatepoint ###
%% syntaxe : A u translatepoint --> B image de A par la translation de vecteur u
/translatepoint {
   addv
} def

%%%%% ### rotatepoint ###
%% syntaxe : B A r rotatepoint --> C image de B par la rotation de centre A,
%% d'angle r (en degre)
%% En prenant les affixes des pts associes, il vient
%%    (zC - zA) = (zB-zA) e^(ir)
%% soit 
%%    zC = (zB-zA) e^(ir) + zA
/rotatepoint {     %% B, A, r
   5 copy          %% B, A, r, B, A, r
   cos 5 1 roll    %% B, A, r, cos r, B, A
   4 1 roll        %% B, A, r, cos r, yA, B, xA
   4 1 roll        %% B, A, r, cos r, A, B 
   vecteur         %% B, A, r, cos r, xB-xA, yB-yA
   4 -1 roll sin   %% B, A, cos r, xB-xA, yB-yA, sin r
   4 copy mul      %% B, A, cos r, xB-xA, yB-yA, sin r, cos r, xB-xA, (yB-yA) sin r
   7 1 roll mul    %% B, A, (yB-yA) sin r, cos r, xB-xA, yB-yA, sin r, cos r (xB-xA)
   5 1 roll        %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, yB-yA, sin r
   exch            %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, sin r, yB-yA
   4 -1 roll mul   %% B, A, (yB-yA) sin r, cos r (xB-xA), xB-xA, sin r, (yB-yA)cos r
   3 1 roll mul    %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r, (xB-xA) sin r
   add             %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r +(xB-xA) sin r
   3 1 roll        %% B, A, (yB-yA) cos r + (xB-xA) sin r, (yB-yA) sin r, cos r (xB-xA), 
   exch sub        %% B, A, (yB-yA) cos r + (xB-xA) sin r, cos r (xB-xA)-(yB-yA) sin r 
   exch            %% B, zA, (zB-zA) e^(ir)
   addv
   3 -1 roll pop
   3 -1 roll pop
} def

%%%%% ### hompoint ###
%% syntaxe : B A alpha hompoint -> le point A' tel que AA' = alpha AB
/hompoint {
   5 copy
   pop
   vecteur      %% vecteur BA
   3 -1 roll
   neg
   mulv   %% alpha x vecteur AB
   addv
   4 -1 roll
   4 -1 roll
   pop pop
} def

%%%%% ### orthoproj ###
%% syntaxe : A D orthoproj --> B, le projete orthogonal de A sur D
/orthoproj {
   6 -1 roll
   6 -1 roll            %% D A
   6 copy               %% D A D A
   7 -1 roll pop
   7 -1 roll pop        %% D D A
   perp 
   interdroite
} def

%% syntaxe : A projx --> le projete orthogonal de A sur Ox
/projx {
   pop 0
} def

%% syntaxe : A projy --> le projete orthogonal de A sur Oy
/projy {
   exch pop 0 exch
} def

%%%%% ### sympoint ###
%% syntaxe : A I sympoint --> point A', le symetrique de A par rapport
%% au point I
/sympoint {
   4 copy
   pop pop
   vecteur 
   -2 mulv
   addv
} def

%%%%% ### axesympoint ###
%% syntaxe : A D axesympoint --> point B, le symetrique de A par rapport
%% a la droite D
/axesympoint {
2 dict begin
   6 copy
   pop pop pop pop
   /yA exch def
   /xA exch def
   orthoproj 
   xA yA vecteur 
   -2 mulv
   xA yA addv
end   
} def

%%%%% ### cpoint ###
%% syntaxe : alpha C cpoint -> M, le point du cercle C correspondant a
%% l'angle alpha
/cpoint {           %% a, xI, yI, r 
1 dict begin
   dup              %% a, xI, yI, r, r
   5 -1 roll        %% xI, yI, r, r, a
   /alpha exch def  
   alpha cos mul    %% xI, yI, r, r cos a
   exch
   alpha sin mul    %% xI, yI, r cos a, r sin a
   3 -1 roll add    %% xI, r cos a, yI + r sin a
   3 1 roll         %% yI + r sin a, xI, r cos a, 
   add exch         %% xI + r cos a, yI + r sin a
end
} def

%%%%% ### xdpoint ###
%% x A B xdpoint : le point de la droite (AB) d'abscisse x
/xdpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /x exch def
   /a pt1 pt2 coeffdir def
   /b pt1 pt2 ordorig def
   x dup a mul b add
end   
} def

%%%%% ### ydpoint ###
%% y A B ydpoint : le point de la droite (AB) d'ordonnee y
/ydpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /y exch def
   pt1 pt2 verticale? 
      {
         pt1 pop y
      }
      {
         /a pt1 pt2 coeffdir def
         /b pt1 pt2 ordorig def
         y b sub a div y
      }
   ifelse
end   
} def

%%%%% ### ordonnepoints ###
%% syntaxe : xA yA xB yB ordonnepoints --> idem si yB>yA ou si yB=yA
%% avec xB>xA, sinon xB yB xA yA
/ordonnepoints {
   4 copy
   exch pop             %% ... xA, yA, yB
   lt                   %% yA < yB ?
      {pop}                     %% oui, c'est fini
      {                         %% non : yA >= yB
         pop 4 copy  
         exch pop               %% ... xA, yA, yB
         eq                     %% yA = yB ?
            {
               3 copy                   %% oui, yA = yB
               pop pop                  %% ... xA, xB
               le                       %% xA =< xB ?
                  {}                          %% oui, c'est fini
                  {                           %% non, on echange A et B
                     4 -1 roll
                     4 -1 roll
                  }
               ifelse
            }
            {                           %% non : yA < yB => on echange A et B
               pop
               4 -1 roll
               4 -1 roll
            }
         ifelse
      } 
   ifelse
} def

%%%%% ### distance ###
%% syntaxe~: A B distance
/distance {      %% xA yA xB yB
   vecteur       %% x y
   dup mul exch  %% y^2 x
   dup mul       %% y^2 x^2
   add
   sqrt
} def

%%%%% ### dup ###
/dupp {2 copy} def
/dupc {3 copy} def
/dupd {4 copy} def

%%%%% ### fin insertion ###
/interdroites {interdroite} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 vecteurs                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### vecteur ###
%% syntaxe~: A B vecteur
/vecteur {
                %% xA yA xB yB 
   3 -1 roll    %% xA xB yB yA 
   sub          %% xA xB yB-yA 
   3 1 roll     %% yB-yA xA xB 
   exch sub     %% yB-yA xB-xA 
   exch
} def

%%%%% ### normalize ###
%% syntaxe : u normalize -> u / ||u||
/normalize {
2 dict begin
   /u defpoint
   /n u norme def
   u 1 n div mulv
end
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### subv ###
%% syntaxe : u v subv --> u - v
/subv {	%% xA yA xB yB
   -1 mulv
   addv
} def

%%%%% ### mulv ###
%% syntaxe : u a mulv --> au
/mulv {   %% xA, yA, a
   dup          %% xA, yA, a, a
   3 1 roll     %% xA, a, yA, a
   mul 3 1 roll %% ayA, xA, a
   mul exch
} def

%%%%% ### scalprod ###
%% syntaxe : u v scalprod --> le produit scalaire de u par v
/scalprod {
2 dict begin
   /y' exch def
   exch 
   /y exch def
   mul y y' mul add
end
} def

%%%%% ### normal ###
%% syntaxe : u normal --> v tel u.v = 0
/normal {
   neg exch
} def

%%%%% ### norme ###
%% syntaxe : u norme --> |u|
/norme {
   dup mul
   exch
   dup mul
   add sqrt
} def

%%%%% ### oldarrow ###
%% syntaxe : A B oldarrow --> trace fleche en B, direction AB
/oldarrow {
4 dict begin
gsave
   /B defpoint
   /A defpoint
   oldarrowscale scale
   oldarrowangle rotate
   newpath 
   B smoveto
   A B vecteur normalize /u defpoint
   u neg exch /v defpoint
   u oldarrowpointe neg mulv rmoveto %% ainsi c'est la pointe qui est en (0, 0)
   %% le pt extremal arriere haut
      u oldarrowplume neg mulv        %% l'abscisse
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul mulv addv %% l'ordonnee
   rlineto
      u oldarrowplume oldarrowpointe add mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto 
      u oldarrowplume oldarrowpointe add neg mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto
   closepath Fill
grestore
end
} def

/oldarrowpointe {xunit 5 div} def
/oldarrowplume {xunit 10 div} def 
/oldarrow@ngle 45 def        
/oldarrowscale {1 1} def
/oldarrowangle 0 def     %% pour l'utilisateur

%%%%% ### drawvecteur ###
%% syntaxe : A B drawvecteur
/drawvecteur {
2 dict begin
   /B defpoint
   /A defpoint
   [A B] ligne
   A B oldarrow
end
} def

%%%%% ### orthovecteur ###
%% syntaxe : u orthovecteur --> v, vecteur orthogonal a u
/orthovecteur {
   neg exch
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  cercles                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### defcercle ###
%% syntaxe : A r /d defcercle
/defcercle {
1 dict begin
   /t@mp@r@ire exch def
   [ 4 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### interdroitecercle ###
%% intersection de la droite y = ax+b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%% { --       b - y                   2          2           3
%% { |  x = - -----, y = (b + a x0 + a  y0 + (2 a  b y0 - 2 a  b x0 +
%% { --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%% 
%%    -- 
%%     |,
%%    -- 
%%     --       b - y                   2          2           3
%%     |  x = - -----, y = (b + a x0 + a  y0 - (2 a  b y0 - 2 a  b x0 +
%%     --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%%    -- }
%%     | }
%%    -- }

%% intersection de la droite x = a avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[x = a, y = y0 + (2 a x0 - a  + r  - x0 )   ],
%% 
%%                                2    2     2 1/2
%%    [x = a, y = y0 - (2 a x0 - a  + r  - x0 )   ]}

%% intersection de la droite y = b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[y = b, x = x0 + (2 b y0 - b  + r  - y0 )   ],
%% 
%%                                2    2     2 1/2
%%    [y = b, x = x0 - (2 b y0 - b  + r  - y0 )   ]}

%% syntaxe : D I r interdroitecercle
/interdroitecercle {
16 dict begin
   /r exch def
   /y0 exch def
   /x0 exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def

   xA yA xB yB verticale?

   %% la droite est verticale
   {
      /xpt1 xA def
      /xpt2 xA def
      /quantite 
         2 xA mul x0 mul xA dup mul sub r dup mul add x0 dup mul sub sqrt
      def
      /ypt1
         y0 quantite add
      def
      /ypt2
         y0 quantite sub
      def
   }

   %% la droite n'est pas verticale
   {
      /a xA yA xB yB coeffdir def
      /b xA yA xB yB ordorig def

      0 a eq 
      %% la droite est horizontale
      {
         /quantite
            2 b mul y0 mul 
            b dup mul sub
            r dup mul add
            y0 dup mul sub
            sqrt
         def
         /xpt1 
            x0 quantite add
         def
         /xpt2 
            x0 quantite sub
         def
         /ypt1 b def
         /ypt2 b def
      } 

      %% la droite n'est pas horizontale
      {
         /quantite1 
            b 
            a x0 mul add
            a dup mul y0 mul add
         def
         /quantite2
            2 a dup mul mul b mul y0 mul 
            2 a 3 exp mul b mul x0 mul sub
            2 a 3 exp mul x0 mul y0 mul add
            a dup mul b dup mul mul sub
            a dup mul r dup mul mul add
            a 4 exp r dup mul mul add
            a dup mul y0 dup mul mul sub
            a 4 exp x0 dup mul mul sub 
            sqrt 
         def
         /quantite3 
            a dup mul 1 add 
         def
         /ypt1
            quantite1 quantite2 add quantite3 div
         def
         /xpt1 
            ypt1 b sub a div 
         def
         /ypt2
            quantite1 quantite2 sub quantite3 div
         def
         /xpt2 
            ypt2 b sub a div 
         def
      } 
      ifelse
   }
   ifelse
   
   xpt1 ypt1 
   xpt2 ypt2 
   ordonnepoints
end
} def

%%%%% ### intercercle ###
%% syntaxe : cerc1 cerc2 intercercle --> A B les points d'intersection
%% des 2 cercles, tries par 'ordonnepoints'
/intercercle {
12 dict begin
   /r2 exch def
   /y2 exch def
   /x2 exch def
   /r1 exch def
   /y1 exch def
   /x1 exch def

   %% on translate pour se ramener a (x1, y1) = (0, 0)
   x2 y2 x1 y1 subv
   /y2 exch def
   /x2 exch def

   %% on prepare l'equation du 2nd degre

%%                    2       2    2
%%   {y = RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ), x = 1/2 (-2 y2
%% 
%%                     2       2    2
%%         RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2       2     2     2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ) + r1~  + x2  + y2
%% 
%%               2
%%          - r2~ )/x2}

   %% coeff pour le degre 2
   /a 
      %%                    2       2    2
      %%   {y = RootOf((4 x2  + 4 y2 ) _Z
      4 x2 dup mul mul
      4 y2 dup mul mul add
   def

   %% coeff pour le degre 1
   %%
   /b 
      %%                    3        2              2       2        
      %%            + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z 
      -4 y2 3 exp mul
      4 r1 dup mul mul y2 mul sub
      4 r2 dup mul mul y2 mul add
      4 x2 dup mul mul y2 mul sub
   def

   %% coeff pour le degre 0
   %%
   /c {
      %%              4
      %%          + x2
      x2 4 exp
      %% 
      %%               4       2    2       2   2       2    2        2   2
      %%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
      r2 4 exp add
      2 y2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul y2 dup mul mul add
      2 x2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul r1 dup mul mul sub
      %% 
      %%               4     4        2   2        2    2
      %%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ )
      r1 4 exp add
      y2 4 exp add
      2 r1 dup mul mul y2 dup mul mul add
      2 r1 dup mul mul r2 dup mul mul sub
   } def

   a b c solve2nddegre
   /Y1 exch def
   /Y0 exch def
   
   /X0
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y0 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def
   
   /X1
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y1 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def

   %% on depose le resultat, en n'oubliant pas de retranslater en sens
   %% inverse

   X0 Y0 x1 y1 addv
   X1 Y1 x1 y1 addv
   ordonnepoints
end
} def

%%%%% ### ABcercle ###
%% syntaxe : A B C ABcercle --> le cercle passant par A, B, C
/ABcercle {
3 dict begin
   /@3 defpoint
   /@2 defpoint
   /@1 defpoint
   @1 @2 mediatrice
   @1 @3 mediatrice
   interdroite
   dupp
   @3 distance
end   
} def

%%%%% ### diamcercle ###
%% syntaxe : A B diamcercle --> le cercle de diametre [AB]
/diamcercle {
   4 copy
   distance 2 div
   5 1 roll 
   milieu
   3 -1 roll 
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  droites                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### horizontale ###
%% syntaxe : y horizontale 
/horizontale {
1 dict begin
   /y exch def
   xmin y xmax y
end
} def

%%%%% ### coeffdir ###
%% syntaxe~: A B coeffdir
/coeffdir {
   vecteur exch div
} def

%%%%% ### ordorig ###
%% syntaxe : A B ordorig
%% attention, la droite est supposee ne pas etre verticale
/ordorig {
   /dr@ite 4 array def
   dr@ite 3 3 -1 roll put
   dr@ite 2 3 -1 roll put
   dr@ite 1 3 -1 roll put
   dr@ite 0 3 -1 roll put
   dr@ite aload pop coeffdir /c@eff exch def
   dr@ite aload pop pop pop  %% xA yA
   exch                      %% yA xA 
   c@eff mul neg add
} def

%%%%% ### verticale ###
%% syntaxe~: A B verticale?
/verticale? {
   pop 2 1 roll pop
   eq
} def

%% syntaxe : x verticale
/verticale {
1 dict begin
   /x exch def
   x ymin x ymax
end
} def

%%%%% ### droite ###
%% %% syntaxe : A B droite
%% /droite {
%% gsave
%% 6 dict begin
%%    /yB exch def
%%    /xB exch def
%%    /yA exch def
%%    /xA exch def
%%    xA yA xB yB
%%    eqp
%%       {}
%%       { 
%%          xA yA xB yB
%%    	 verticale?
%%    	 {
%%    	 newpath
%%    	    xA ymin smoveto
%%    	    xA ymax slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 {
%%    	 newpath
%%    	    /alpha xA yA xB yB coeffdir def
%%    	    /beta xA yA xB yB ordorig def
%%    	    xmin dup alpha mul beta add smoveto
%%    	    xmax dup alpha mul beta add slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 ifelse
%%       }
%%    ifelse
%% end
%% grestore
%% } def

%% syntaxe : A B droite
/droite {
gsave
6 dict begin
   /B defpoint
   /A defpoint
   A pop B pop eq {
      %% droite verticale
      newpath
         A pop ymin smoveto
	 A pop ymax slineto
         stockcurrentcpath
      Stroke
   } {
      %% on cherche le point le + a gauche
      xmin A B xdpoint /C defpoint
      C exch pop ymin lt {
         %% trop a gauche
	 ymin A B ydpoint /C defpoint
      } if
      C exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /C defpoint
      } if
      %% on cherche le point le + a droite
      xmax A B xdpoint /D defpoint
      D exch pop ymin lt {
         %% trop a droite
	 ymin A B ydpoint /D defpoint
      } if
      D exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /D defpoint
      } if
      newpath
         C smoveto
         D slineto
         stockcurrentcpath
     Stroke
   } ifelse
end
grestore
} def

%%%%% ### defdroite ###
%% syntaxe : A B /d defdroite
/defdroite {
1 dict begin
   /t@mp@r@ire exch def
   [ 5 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### paral ###
%% syntaxe : D A paral --> droite parallele a D passant par A
/paral {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### interdroite ###
/interdroite {
                %% A B C D
   /dr@ite2 4 array def
   dr@ite2 3 3 -1 roll put
   dr@ite2 2 3 -1 roll put
   dr@ite2 1 3 -1 roll put
   dr@ite2 0 3 -1 roll put
   /dr@ite1 4 array def
   dr@ite1 3 3 -1 roll put
   dr@ite1 2 3 -1 roll put
   dr@ite1 1 3 -1 roll put
   dr@ite1 0 3 -1 roll put

%%%    %% trace pour deboguage
%%%    dr@ite1 aload pop droite
%%%    dr@ite2 aload pop droite

%%% Dans tous les cas, on suppose que l'intersection existe
%%% 
%%% * la 1ere droite est verticale. les equations reduites sont
%%%       x = a1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%       {{x = a1, y = b2 + a1 a2}}
%%% 
%%% * la 2eme droite est verticale. les equations reduites sont
%%%       x = a1 x+ b1     et       x = a2
%%% Le point d'intersection est :
%%%       {{x = a2, y = b1 + a1 a2}}
%%% 
%%% * aucune n'est verticale. Les equations reduites sont
%%%       y = a1 x + b1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%                 { {     b2 - b1      a1 b2 - a2 b1 } }
%%%                 { { x = -------, y = ------------- } }
%%%                 { {     a1 - a2         a1 - a2    } }

%%% remarque : pour le moment, je n'arrive pas a rendre mes variables
%%% locales : elle restent globales. Pour que cela ne soit pas trop
%%% genant, je les note respectivement @1, @@1, @2 et @@2 au lieu de a1,
%%% b1, a2 et b2.

   dr@ite1 aload pop verticale?
      {
         /@1 {dr@ite1 aload pop pop pop pop} def
         /@2 {dr@ite2 aload pop coeffdir} def
         /@@2 {dr@ite2 aload pop ordorig} def
         @1 
         @1 @2 mul @@2 add
      }
      {
      dr@ite2 aload pop verticale?
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop pop pop pop} def
            @2
            @1 @2 mul @@1 add
         }
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop coeffdir} def
            /@@2 {dr@ite2 aload pop ordorig} def
            @@2 @@1 sub @1 @2 sub div
            @1 @@2 mul @2 @@1 mul sub
            @1 @2 sub div
         }
      ifelse
      }
   ifelse
} def

%%%%% ### perp ###
%% syntaxe : D A perp --> droite perpendiculaire a D passant par A
/perp {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur orthovecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### mediatrice ###
%% synaxe : A B mediatrice --> droite
/mediatrice {
   4 copy 
   milieu
   perp
} def

%%%%% ### bissectrice ###
%% syntaxe : A B C bissectrice --> B E ou E est un point de la bissectrice
/bissectrice {
10 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /alpha {A B C tripointangle} def
   B
   A B alpha rotatepoint
   A milieu
end
} def

%%%%% ### angledroit  ###
 /widthangledroit 5 def

%% syntaxe : A B C angledroit --> dessine un angle droit en B
/angledroit {
10 dict begin
   dup xcheck {
      /widthangledroit exch def
   } if
   /C defpoint
   /B defpoint
   /A defpoint
   B C vecteur normalize widthangledroit 20 div mulv /u defpoint
   B A vecteur normalize widthangledroit 20 div mulv /v defpoint
   [B u addv dupp v addv B v addv] ligne
end
} def

%%%%% ### translatedroite ###
%% syntaxe : A B u translatedroite --> C D images resp de A et B par la translation de vecteur u
/translatedroite {         %% A B u
   2 copy          %% A B u u
   6 1 roll       
   6 1 roll        %% A u B u 
   addv      %% A u D
   6 1 roll        
   6 1 roll        %% D A u 
   addv
   4 1 roll
   4 1 roll
} def

%%%%% ### rotatedroite ###
%% syntaxe : A B O r rotatedroite --> C D images resp de A et B par la
%% rotation de centre O et d'angle r (en degre)
/rotatedroite {
   5 copy rotatepoint   %% A B O r D
   6 -1 roll pop        %% A xB O r D
   6 -1 roll pop        %% A O r D
   7 1 roll
   7 1 roll rotatepoint %% D C
   4 1 roll 4 1 roll 
} def

/rotatevecteur {
   rotatedroite
} def

/rotatesegment {
   rotatedroite
} def

%%%%% ### axesymdroite ###
%% syntaxe : d D axesymdroite --> droite d', symetrique de la droite d par rapport
%% a la droite D
/axesymdroite {
2 dict begin
   /D defdroite
   /B defpoint
   D axesympoint
   B D axesympoint
end   
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  polygones                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### poltransformfile ###
%% syntaxe : pol u translatepol --> pol'
/translatepol {
2 dict begin   
   /uy exch def
   /ux exch def
   {ux uy translatepoint} papply
end
} def

%% syntaxe : pol u rotatepol --> pol'
/rotatepol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha rotatepoint} papply
end
} def

%% syntaxe : pol I alpha hompol --> pol'
/hompol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha hompoint} papply
end
} def

%% syntaxe : pol I sympol --> pol'
/sympol {
1 dict begin   
   /I defpoint
   {I sympoint} papply
end
} def

%% syntaxe : pol D axesympol --> pol'
/axesympol {
1 dict begin   
   /D defdroite
   {D axesympoint} papply
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  les tests                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### isbool ###
%% syntaxe : any isbool --> booleen
/isbool {
   type (booleantype) cvn eq
} def

%%%%% ### isarray ###
%% syntaxe : any isarray --> booleen
/isarray {
   type (arraytype) cvn eq
} def

%%%%% ### isstring ###
%% syntaxe : any isstring --> booleen
/isstring {
   type (stringtype) cvn eq
} def

%%%%% ### isinteger ###
%% syntaxe : any isinteger --> booleen
/isinteger {
   type (integertype) cvn eq
} def

%%%%% ### isnum ###
%% syntaxe : any isnum --> booleen
/isnum {
   dup isreal 
   exch isinteger or
} def

%%%%% ### isreal ###
%% syntaxe : any isreal --> booleen
/isreal {
   type (realtype) cvn eq
} def

%%%%% ### eq ###
%% syntaxe : A B eqp3d --> booleen = true si les points A et B sont identiques
/eqp3d {
               %% x1 y1 z1 x2 y2 z2
   4 -1 roll   %% x1 y1 x2 y2 z2 z1 
   eq {        %% x1 y1 x2 y2 
      eqp
   } {
      pop pop pop pop false
   } ifelse
} def

%% syntaxe : A B eqp --> booleen = true si les points A et B sont identiques
/eqp {
   3 -1 roll
   eq 
      {
         eq 
            {true} 
            {false}
         ifelse
      }
      {pop pop false}
   ifelse
} def

%% syntaxe : z z' eqc --> true si z = z', false sinon
/eqc {
   eqp
} def

%%%%% ### eqstring ###
/eqstring {
3 dict begin
   /str2 exch def
   /str1 exch def
   str1 length str2 length eq {
      /i 0 def
      true
      str1 length {
         str1 i get str2 i get eq and
         /i i 1 add store
      } repeat
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                conversions de types                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### astr2str ###
%% syntaxe : array str astr2str --> str
%% convertit le contenu de array en chaines de caracteres puis les
%% concatene avec str, en inserant un caractere "space" apres chaque
%% element du tableau array
/astr2str {
5 dict begin
   /str exch def
   /table exch def
   /n table length def
   n 0 eq {
      str
   } {
      table 0 n 1 sub getinterval
      table n 1 sub get (                               ) cvs
      ( ) append
      str append
      astr2str
   } ifelse
end
} def

%%%%% ### numstr2array ###
%% syntaxe : str str2num --> num
/str2num {
5 dict begin
   /str exch def
   /n str length def
   /signnum 1 def
   /frct false def
   /k 0 def
   0 1 n 1 sub {
      /i exch def
      str i get
      dup 46 eq {
         %% il y a un point
         /frct true def
         pop
         i 0 eq {
            0
         } if
      } {
         dup 45 eq {
            /signnum -1 def
            pop
         } {
            frct not {
               i 1 ge signnum 0 ge and i 2 ge or {
                  exch 10 mul 48 sub add
               } {
                  48 sub
               } ifelse
            } {
               48 sub
               /k k 1 add store
               10 k exp div add
            } ifelse
         } ifelse
      } ifelse
   } for
   signnum mul
end
} def

/str2num {cvx exec} def

%% syntaxe : str numstr2array -> array
%% ou str est une chaine de nombres reels separes par des espaces
%% et array est constitue des elements numeriques de string.
%% exemple :
%% (0 -12 .234 54) --> [0 -12 0.234 54]
/numstr2array {
6 dict begin
   /str exch def
   /n str length def
   /separateurs [] def
   [
      0 1 n 1 sub {
         /i exch def
         str i get
         32 eq {
            /separateurs [separateurs aload pop i] def
         } if
      } for
      /j 0 def
      /oldsep 0 def
      0 1 separateurs length 1 sub {
         /i exch def
         str j separateurs i get oldsep sub getinterval str2num
         /j separateurs i get 1 add def
         /oldsep separateurs i get 1 add def
      } for
      str j n oldsep sub getinterval str2num
   ]
end
} def

%% syntaxe : array numstr2array -> array
/arraynumstr2arrayarray {
   {numstr2array} apply
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                macros de projection                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### projtext ###
%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str x0 y0 plantype ultextp3d --> -
%% syntaxe : str x0 y0 plantype bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
 /initpr@jtext {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /type_plan_proj true def
      /lepl@n exch def
      lepl@n plangetbase aload pop
      /@V defpoint3d
      /@U defpoint3d
      lepl@n plangetorigine
      /z0 exch def
      /y0 exch def
      /x0 exch def
      /table [@U @U @V vectprod3d] def
   } {
      dup isarray {
         %% c est un planprojpath
         /type_plan_proj true def
         /table exch def
         /z0 exch def
         /y0 exch def
         /x0 exch def
         0 0
      } {
         %% c est un solidprojpath
         /type_plan_proj false def
         %% y a-t-il un str2
         dup isstring {
            /str2 exch def
         } {
            /str2 {} def
         } ifelse
         %% y a-t-il un alpha
         2 copy pop issolid {
            /alpha 0 def
         } {
            /alpha exch def
         } ifelse
         /i exch def
         /solid exch def
         0 0
      } ifelse
   } ifelse
} def
 /closepr@jtext {
   type_plan_proj {
      x0 y0 z0 table mybool projpath
   } {
      solid i alpha str2 mybool projpath
   } ifelse
   Fill
   Stroke
end
} def

%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
/ultextp3d {initpr@jtext ultext_ closepr@jtext} def
/cltextp3d {initpr@jtext cltext_ closepr@jtext} def
/bltextp3d {initpr@jtext bltext_ closepr@jtext} def
/dltextp3d {initpr@jtext dltext_ closepr@jtext} def
/ubtextp3d {initpr@jtext ubtext_ closepr@jtext} def
/cbtextp3d {initpr@jtext cbtext_ closepr@jtext} def
/bbtextp3d {initpr@jtext bbtext_ closepr@jtext} def
/dbtextp3d {initpr@jtext dbtext_ closepr@jtext} def
/uctextp3d {initpr@jtext uctext_ closepr@jtext} def
/cctextp3d {initpr@jtext cctext_ closepr@jtext} def
/bctextp3d {initpr@jtext bctext_ closepr@jtext} def
/dctextp3d {initpr@jtext dctext_ closepr@jtext} def
/urtextp3d {initpr@jtext urtext_ closepr@jtext} def
/crtextp3d {initpr@jtext crtext_ closepr@jtext} def
/brtextp3d {initpr@jtext brtext_ closepr@jtext} def
/drtextp3d {initpr@jtext drtext_ closepr@jtext} def

%%%%% ### currentppathtransform ###
%% syntaxe : {f} currentppathtransform --> applique la transformation f
%% au chemin courant
/currentppathtransform {
6 dict begin
   /warp exch def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp moveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp lineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      curveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%% syntaxe : {f} currentpathtransform --> applique la transformation f
%% au chemin courant
/currentpathtransform {
7 dict begin
   /transform exch def
   /warp {ptojpoint transform} def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp smoveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp slineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      scurveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%%%%% ### normalvect_to_orthobase ###
%% syntaxe : [normal_vect] normalvect_to_orthobase
%%    --> imI imJ imK
/normalvect_to_orthobase {
4 dict begin
   dup length 3 eq {
      aload pop normalize3d /normal_vect defpoint3d
      normal_vect -1 0 0 eqp3d {
         /imageI {0 -1 0} def
         /imageK {-1 0 0} def
         /imageJ {0 0 1} def 
      } {
         %% on calcule l image de la base (I,J,K)
         /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
         /imageK {normal_vect} def
         /imageI {imageJ imageK vectprod3d} def
         1 0 0 imageK angle3d 0 eq {
            0 1 0 normal_vect vectprod3d /imageI defpoint3d
            /imageJ {0 1 0} def
            normal_vect /imageK defpoint3d
         } if
      } ifelse
   } {
      dup length 6 eq {
         aload pop
         normalize3d /imageK defpoint3d
         normalize3d /imageI defpoint3d
         imageK imageI vectprod3d /imageJ defpoint3d
      } {
         dup length 7 eq {
            aload pop 
            /alpha exch 2 div def
            normalize3d /imageK defpoint3d
            normalize3d /imageI defpoint3d
            imageK imageI vectprod3d /imageJ defpoint3d
            %% et ensuite, on fait tourner la base autour de imageK
            imageI alpha cos mulv3d
            imageJ alpha sin mulv3d
            addv3d
   
            imageI alpha sin neg mulv3d
            imageJ alpha cos mulv3d
            addv3d
   
            /imageJ defpoint3d
            /imageI defpoint3d
         } {
            %% length = 4
            aload pop
            /alpha exch def
            normalize3d /normal_vect defpoint3d
   
            normal_vect -1 0 0 eqp3d {
               /imageI {0 -1 0} def
               /imageK {-1 0 0} def
               /imageJ {0 0 1} def 
            } {
               %% on calcule l image de la base (I,J,K)
               /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
               /imageK {normal_vect} def
               /imageI {imageJ imageK vectprod3d} def
               1 0 0 imageK angle3d 0 eq {
                  0 1 0 normal_vect vectprod3d /imageI defpoint3d
                  /imageJ {0 1 0} def
                  normal_vect /imageK defpoint3d
               } if
            } ifelse
         } ifelse

         %% et ensuite, on fait tourner la base autour de imageK
         imageI alpha cos mulv3d
         imageJ alpha sin mulv3d
         addv3d

         imageI alpha sin neg mulv3d
         imageJ alpha cos mulv3d
         addv3d

         /imageJ defpoint3d
         /imageI defpoint3d
      } ifelse
   } ifelse
   imageI
   imageJ
   imageK
end
} def

%%%%% ### projpath ###
%% syntaxe : x y z [normal] projpath --> planprojpath
%% syntaxe : x y z [normal] bool projpath --> planprojpath
%% syntaxe : solid i projpath --> solidprojpath
%% syntaxe : solid i bool projpath --> solidprojpath
%% syntaxe : solid i str bool projpath --> solidprojpath
%% syntaxe : solid i alpha str bool projpath --> solidprojpath
/projpath {
2 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      3 dict begin
         /lepl@n exch def
         lepl@n plangetbase aload pop
         /@V defpoint3d
         /@U defpoint3d
         lepl@n plangetorigine
         [@U @U @V vectprod3d] mybool planprojpath
      end
   } {
      dup isarray {
         mybool planprojpath
      } {
         mybool solidprojpath
      } ifelse
   } ifelse
end
} def


%% %% syntaxe : x y z [normal] projpath --> planprojpath
%% %% syntaxe : x y z [normal] bool projpath --> planprojpath
%% %% syntaxe : solid i projpath --> solidprojpath
%% %% syntaxe : solid i bool projpath --> solidprojpath
%% %% syntaxe : solid i str bool projpath --> solidprojpath
%% %% syntaxe : solid i alpha str bool projpath --> solidprojpath
%% /projpath {
%% 2 dict begin
%%    dup isbool {
%%       /mybool exch def
%%    } {
%%       /mybool true def
%%    } ifelse
%%    dup isarray {
%%       mybool planprojpath
%%    } {
%%       mybool solidprojpath
%%    } ifelse
%% end
%% } def
%% 
%% syntaxe : solid i str bool solidprojpath --> -
%% ou
%% syntaxe : solid i alpha str bool solidprojpath --> -
%% projette le chemin courant sur la face i du solide, apres
%% eventuellement une rotation d angle alpha autour de la normale
%% bool : pour savoir si on tient compte de la visibilite
/solidprojpath {
5 dict begin
   /visibility exch def
   dup isstring {
      /option exch def
   } if
   2 copy pop
   issolid {
      /alpha 0 def
   } {
      /alpha exch def
   } ifelse
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidprojpath) ==
   } if
   /n solid solidnombrefaces def
   i n 1 sub le {
      visibility not solid i solidfacevisible? or {
         currentdict /option known {
            option cvx exec
         } {
            solid i solidcentreface 
         } ifelse
         [
            solid 0 i solidgetsommetface 
            solid 1 i solidgetsommetface 
            vecteur3d normalize3d
            solid i solidnormaleface alpha 
         ] false planprojpath 
      } {
         newpath 0 0 smoveto
      } ifelse
   } {
      (Error : indice trop grand dans solidprojpath) ==
      quit
   } ifelse
end
} def

%% syntaxe : x y z [normal] bool planprojpath
/planprojpath {
6 dict begin
   /visibility exch def
   %% on calcule l image de la base (I,J,K)
   normalvect_to_orthobase
   /imageK defpoint3d
   /imageJ defpoint3d
   /imageI defpoint3d
   /z exch def
   /y exch def
   /x exch def

   visibility not x y z imageK planvisible? or {
      {ptojpoint 0
      imageI
      imageJ
      imageK
      transformpoint3d
      x y z addv3d
      3dto2d jtoppoint} currentppathtransform
   } {
      newpath
   } ifelse
end
} def

%%%%% ### projscene ###
%% syntaxe : plantype bool bprojscene ... eprojscene
/bprojscene {
10 dict begin
gsave
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /l@pl@n exch def
   /saveStroke {SolidesDict /Stroke get exec} def
   /Stroke {l@pl@n mybool projpath saveStroke} def
   /savefill {SolidesDict /Fill get exec} def
   /Fill {l@pl@n mybool projpath savefill} def
   /masque {} def
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
%%       xmin ymin l@pl@n pointplan smoveto
%%       xmin ymax l@pl@n pointplan slineto
%%       xmax ymax l@pl@n pointplan slineto
%%       xmax ymin l@pl@n pointplan slineto
%%       xmin ymin l@pl@n pointplan smoveto
%%  %   closepath
%% %gsave orange Fill grestore
%%    clip
} def
/eprojscene {
grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          fonctions numeriques                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### courbeparam ###
/setresolution {
   /resolution exch def
} def
%/resolution 200 def % ---- hv 20110713

/courbe_dic 2 dict def
courbe_dic /X {} put
courbe_dic /Y {} put

%% syntaxe : tmin tmax C@urbeparam_
 /C@urbeparam_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR
   tmin@ courbe_dic /Y get exec
   pstrickactionR
   smoveto
   resolution 1 sub
   {
      t courbe_dic /X get exec
      pstrickactionR
      t courbe_dic /Y get exec
      pstrickactionR
      slineto

      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR
   tmax@ courbe_dic /Y get exec
   pstrickactionR
   slineto
end
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam_
/Courbeparam_ {
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   C@urbeparam_
} def

%% syntaxe : {X} {Y} courbeparam_
/courbeparam_ {
   tmin tmax
   4 -1 roll
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam
/Courbeparam {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin courbe_dic /X get exec
      pstrickactionR
      tmin courbe_dic /Y get exec
      pstrickactionR
      smoveto                        %% on commence le chemin
      tmin tmax C@urbeparam_
      starfill

   stockcurrentcpath
   newarrowpath
   currentdict /option known
      {
         /dt tmax tmin sub resolution 1 sub div def
         tmin dt add courbe_dic /X get exec
         tmin dt add courbe_dic /Y get exec
         tmin courbe_dic /X get exec
         tmin courbe_dic /Y get exec
         arrowpath0
         tmax dt sub courbe_dic /X get exec
         tmax dt sub courbe_dic /Y get exec
         tmax courbe_dic /X get exec
         tmax courbe_dic /Y get exec
         currentdict /dt undef
         arrowpath1
         option
         gere_arrowhead
      }
   if

   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} {Y} courbeparam
/courbeparam {
   dup isstring
      {
         tmin tmax
         5 -1 roll
         5 -1 roll
         5 -1 roll
      }
      {
         tmin tmax
         4 -1 roll
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam*
/Courbeparam* {
1 dict begin
   /startest {true} def
   Courbeparam
end
} def

%% syntaxe : {X} {Y} courbeparam*
/courbeparam* {
1 dict begin
   /startest {true} def
   courbeparam
end
} def

%%%%% ### courbe ###
%% syntaxe : {f} courbe
/courbe {
   dup isstring   %% y a-t-il une option de fin de ligne ?
      {
         xmin xmax 
         {} 
         5 -1 roll
         5 -1 roll
      }
      {
         xmin xmax 
         {} 
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : mini maxi {f} Courbe
/Courbe {
   dup isstring {
      {}
      3 -1 roll
      3 -1 roll
   } {
      {}
      2 -1 roll
   } ifelse
   Courbeparam
} def

%% syntaxe : {f} courbe_
/courbe_ {
   xmin xmax 
   {} 
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe_
/Courbe_ {
   {}
   2 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe*
/Courbe* {
1 dict begin
   /startest {true} def
   Courbe
end
} def

%% syntaxe : {f} courbe*
/courbe* {
1 dict begin
   /startest {true} def
   courbe
end
} def

%%%%% ### courbeR2 ###
%% syntaxe : tmin tmax C@urbeR2_
 /C@urbeR2_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR2
   smoveto
   /t t dt add store
   resolution 2 sub
   {
      t courbe_dic /X get exec
      pstrickactionR2
      slineto
      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR2
   slineto
end
} def

%% syntaxe : tmin tmax {X} CourbeR2_
/CourbeR2_ {
   courbe_dic exch /X exch put
   C@urbeR2_
} def

%% syntaxe : {X} courbeR2_
/courbeR2_ {
   tmin tmax
   3 -1 roll
   3 -1 roll
   CourbeR2_
} def

%% syntaxe : tmin tmax {X} CourbeR2
/CourbeR2+ {
2 dict begin
   /slineto {} def
   /smoveto {} def
   CourbeR2
end
} bind def

/CourbeR2 {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin tmax C@urbeR2_
      starfill
   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} courbeR2
/courbeR2 {
   tmin tmax
   3 -1 roll
   CourbeR2
} def

%% syntaxe : tmin tmax {X} CourbeR2*
/CourbeR2* {
1 dict begin
   /startest {true} def
   CourbeR2
end
} def

%% syntaxe : {X} {Y} courbeR2*
/courbeR2* {
1 dict begin
   /startest {true} def
   courbeR2
end
} def

%%%%% ### courbeR3 ###
%% syntaxe : t1 t2 {f} (option) CourbeR3
/CourbeR3 {
2 dict begin
   dup isstring {
      /option exch def
   } if
   /lafonction exch def
   {lafonction 3dto2d}
   currentdict /option known
      {option}
   if
  CourbeR2
end
} def

%% syntaxe : {f} (option) CourbeR3
/courbeR3 {
   tmin tmax 3 -1 roll CourbeR3
} def

%%%%% ### cercle ###
%% syntaxe : x0 y0 r cercle
/cercle {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam
end
} def

%% syntaxe : x0 y0 r cercle_
/cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle-_
/cercle-_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   360 0 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle*
/cercle* {
1 dict begin
   /startest true def
   cercle
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle {
4 dict begin
   dup isstring
      {/option exch def}
   if
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} 
   currentdict /option known
      {option}
   if
   Courbeparam
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle_
/Cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle* {
1 dict begin
   /startest {true} def
   Cercle
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%      fonctions et constantes mathematiques         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### math ###
%%%%%%%%%%% constantes mathematiques %%%%%%%%%%%%%%

/pi 3.14159 def
/e 2.71828 def

%%%%%%%%%%% fonctions mathematiques %%%%%%%%%%%%%%%

/rd {180 pi div mul} def        %% transforme des rd en degres
/deg {pi mul 180 div} def       %% transforme des degres en rd
/log {ln 10 ln div} def
/Exp {e exch exp} def
/Cos {rd cos} def
/Sin {rd sin} def
/tan {dup sin exch cos div} def
/cotan {dup cos exch sin div} def
/Tan {dup Sin exch Cos div} def
/Cotan {dup Cos exch Sin div} def
/coTan {Cotan} def
/arctan {
dup 0 ge
   {1 atan}
   {neg 1 atan neg}
ifelse
} def
/Arctan {arctan deg} def
/arccos {
   dup
   dup mul neg 1 add sqrt
   exch
   atan
} def
/Arccos {arccos deg} def
/arcsin {
   dup 1 eq {
      90
   } {
      dup
      dup mul neg 1 add sqrt
      atan
      dup 90 lt
         {}
         {360 sub}
      ifelse
   } ifelse
} def
/Arcsin {arcsin deg} def
/cosh {dup Exp exch neg Exp add 2 div} def
/sinh {dup Exp exch neg Exp sub 2 div} def
/tanh {dup sinh exch cosh div} def
/cotanh {dup cosh exch sinh div} def
/argcosh {dup dup mul 1 sub sqrt add ln} def
/argsinh {dup dup mul 1 add sqrt add ln} def
/argtanh {
   setxvar
   x 1 add
   1 x sub
   div
   ln
   2 div
} def
/factorielle {
      dup 0 eq
         {pop 1}
         {dup 1 sub factorielle mul}
      ifelse
} def
/Gauss {
3 dict begin
   /sigma exch def
   /m exch def
   /x exch def
   x m sub dup mul sigma dup mul 2 mul div neg Exp
   2 pi mul sigma dup mul mul sqrt div
end
} def
%% syntaxe : a n modulo
/modulo {
2 dict begin
   /n exch def
   /a exch def
   {
      a 0 lt {
         /a a n add store
      } {
         exit
      } ifelse
   } loop
   a n mod
end
} def

%%%%% ### max ###
/max {
   2 copy
   lt {exch} if
   pop
} def

%%%%% ### min ###
/min {
2 dict begin
   dup isarray {
      duparray /table exch def pop
      table 0 get
      1 1 table length 1 sub {
         /i exch def
         table i get
         min
      } for
   } {
      2 copy
      gt {exch} if
      pop
   } ifelse
end
} def

%%%%% ### setcolor ###
%% syntaxe : tableau setcolor
/setcolor {
   dup length 4 eq
      {aload pop setcmykcolor}
      {aload pop setrgbcolor}
   ifelse
} def

%%%%% ### in ###
%% cherche si un elt donne appartient au tableau donne
%% rque : utilise 3 variables locales
%% syntaxe : elt array in --> index boolean
/in {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         i true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%% cherche si un elt donne appartient au tableau donne
%% syntaxe : elt array in --> boolean
/In {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%%%%% ### starfill ###
%% la procedure pour les objets "star"
%% si c est "star" on fait le fillstyle, sinon non
/starfill {
   startest {
      gsave
         clip
         fillstyle
      grestore
      /startest false def
   } if
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### continu ### 
/continu {
   [] 0 setdash 
} def

%%%%% ### trigospherique ### 
%% passage spherique --> cartesiennes
%% les formules de passage ont t rcupres ici :
%%    http://fr.wikipedia.org/wiki/Coordonn%C3%A9es_polaires
%% syntaxe : r theta phi rtp2xyz -> x y z
/rtp2xyz {
6 dict begin
   /phi exch def
   /theta exch def
   /r exch def
   /x phi cos theta cos mul r mul def 
   /y phi cos theta sin mul r mul def
   /z phi sin r mul def
   x y z
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique {
9 dict begin
   dup isstring {
      /option exch def
   } if
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] 
      currentdict /option known {
         option
      } if
      ligne3d
   grestore
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique_ {
8 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   /t pas neg def
   [
      n 1 add {
         /t  t pas add store
         u t cos r mul mulv3d
         w t sin r mul mulv3d
         addv3d
      } repeat
   ] ligne3d_
end
} def

%% trace d'une geodesique sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 geodesique_sphere
/geodesique_sphere {
13 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 360 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /pas 360 n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] ligne3d
   grestore
end
} def


%% syntaxe : A B C trianglespherique --> trace le rtiangle ABC
%% (coordonnees spheriques)
/trianglespherique* {
1 dict begin
   /startest {true} def
   trianglespherique
end
} def

/trianglespherique {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   gsave
   newpath
      A rtp2xyz 3dto2d smoveto
      A B arcspherique_
      B C arcspherique_
      C A arcspherique_
   closepath
   starfill
   currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         operations sur les tableaux                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### duparray ###
/duparray {
1 dict begin
   /table exch def
   table
   [ table aload pop ]
end
} def

%%%%% ### append ###
%% syntaxe : string1 string2 append --> concatene les 2 chaines ou fusionne 2 tableaux
/append {
3 dict begin
   dup isarray {
      /tab2 exch def
      /tab1 exch def
      [ tab1 aload pop tab2 aload pop ]
   } {
      /str2 exch def
      /str1 exch def
      /result str1 length str2 length add string def
      str1 result copy pop
      result str1 length str2 putinterval
      result
   } ifelse
end
} def

%%%%% ### rollparray ###
%% syntaxe : array n rollparray -> array
%% opere une rotation de n sur les couplets du tableau array
/rollparray {
4 dict begin
   /k exch def
   /table exch def
   /n table length def
   k 0 eq {
       table
   } {
       k 0 ge {
          [ table aload pop 2 {n 1 roll} repeat ]
           k 1 sub
       } {
          [ table aload pop 2 {n -1 roll} repeat ]
           k 1 add
       } ifelse
       rollparray
   } ifelse
end
} def

%%%%% ### bubblesort ###
%% syntaxe : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 15/08/2006
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublebubblesort {
5 dict begin
   /table exch def
   /n table length 1 sub def
   /indices [ 0 1 n {} for ] def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            table i get table i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               table i 1 add
               table i get
               table i table i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put

               indices i 1 add
               indices i get
               indices i indices i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   indices table
end
} def

%%%%% ### quicksort ###
%% src : http://www.math.ubc.ca/~cass/graphics/text/www/code/sort.inc
%% code de Bill Casselman, modifie par jpv, 18/10/2007

/qsortdict 8 dict def

qsortdict begin

% args: /comp a L R x
% effect: effects a partition into two pieces [L j] [i R]
%     leaves i j on stack

/partition { 8 dict begin
/x exch def
/j exch def
/i exch def
/a exch def
load /comp exch def
{
  {
    a i get x comp exec not {
      exit
    } if
    /i i 1 add def
  } loop
  {
    x a j get comp exec not {
      exit
    } if
    /j j 1 sub def
  } loop

  i j le {
    % swap a[i] a[j]
    a j a i get
    a i a j get
    put put
    indices j indices i get
    indices i indices j get
    put put
    /i i 1 add def
    /j j 1 sub def
  } if
  i j gt {
    exit
  } if
} loop
i j
end } def

% args: /comp a L R
% effect: sorts a[L .. R] according to comp

/subsort {
% /c a L R
[ 3 1 roll ] 3 copy
% /c a [L R] /c a [L R]
aload aload pop
% /c a [L R] /c a L R L R
add 2 idiv
% /c a [L R] /c a L R (L+R)/2
3 index exch get
% /c a [L R] /c a L R x
partition
% /c a [L R] i j
% if j > L subsort(a, L, j)
dup
% /c a [L R] i j j
3 index 0 get gt {
  % /c a [L R] i j
  5 copy
  % /c a [L R] i j /c a [L R] i j
  exch pop
  % /c a [L R] i j /c a [L R] j
  exch 0 get exch
  % ... /c a L j
  subsort
} if
% /c a [L R] i j
pop dup
% /c a [L R] i i
% if i < R subsort(a, i, R)
2 index 1 get lt {
  % /c a [L R] i
  exch 1 get
  % /c a i R
  subsort
}{
  4 { pop } repeat
} ifelse
} def

end

% args: /comp a
% effect: sorts the array a
% comp returns truth of x < y for entries in a

/quicksort { qsortdict begin
dup length 1 gt {
% /comp a
dup
% /comp a a
length 1 sub
% /comp a n-1
0 exch subsort
} {
pop pop
} ifelse
end } def

% ----------------------------------------

%% fin du code de Bill Casselman

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 18/10/2007
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublequicksort {
qsortdict begin
   /comp exch
   /a exch def
   a dup length /n exch def
   /indices [0 1 n 1 sub {} for ] def
   dup length 1 gt {
      % /comp a
      dup
      % /comp a a
      length 1 sub
      % /comp a n-1
      0 exch subsort
   } {
      pop pop
   } ifelse
   indices a
end
} def

/comp {lt} def

%%%%% ### apply ###
%% syntaxe : [x1 ... xn] (f) apply --> [f(x1) ... f(xn)]
/apply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length {
      liste @i get fonction
      /@i @i 1 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) papply
/papply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length 2 idiv {
      liste @i get
      liste @i 1 add get
      fonction
      /@i @i 2 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) capply 
/capply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse   
   /liste exch def
   /@i 0 def
   [
   liste length 3 idiv {
      liste @i get 
      liste @i 1 add get 
      liste @i 2 add get 
      fonction
      /@i @i 3 add store
   } repeat
   counttomark 
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### reverse ###
%% syntaxe : array reverse --> inverse l ordre des items dans
%% le tableau
/reverse {
3 dict begin
   /le_tableau exch def
   /n le_tableau length def
   /i n 1 sub def
   [
      n {
         le_tableau i get
         /i i 1 sub store
      } repeat
   ]
end
} def

%% syntaxe : array_points reversep --> inverse l ordre des points dans
%% le tableau
/reversep {
3 dict begin
   /le_tableau exch def
   /n le_tableau length 2 idiv def
   /i n 1 sub def
   [
      n {
         le_tableau i getp
         /i i 1 sub store
      } repeat
   ]
end
} def

%%%%% ### get ###
%% syntaxe : array_points n getp --> le n-ieme point du tableau de
%% points array_points
/getp {
   2 copy
   2 mul get
   3 1 roll
   2 mul 1 add get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             matrices                               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### linear ###
%% syntaxe : M i j any --> depose any dans M en a_ij
/put_ij {
5 dict begin
   /a exch def
   /j exch def
   /i exch def
   /M exch def
   /L M i get_Li def
   L j a put
   M i L put_Li
end
} def

%% syntaxe : M i j get_ij --> le coeff c_ij
/get_ij {
   3 1 roll   %% j M i
   get_Li     %% j L_i
   exch get
} def

%% syntaxe : M i L put_Li --> remplace dans M la ligne Li par L
/put_Li {
   put
} def

%% syntaxe : M i get_Li --> la ligne Li de M
/get_Li {
   get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (calculs)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### p3dtoplane ###
%% syntaxe : x y z P p3dtoplane --> X Y
/p3dtoplane {
5 dict begin
   /leplan exch def
   /M defpoint3d
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   I M vecteur3d U scalprod3d
   I M vecteur3d V scalprod3d
end
} def

%%%%% ### pplaneto3d ###
%% syntaxe : x y P pplaneto3d --> X Y Z
/pplaneto3d {
6 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   U x mulv3d
   V y mulv3d addv3d
   I addv3d
end
} def

%%%%% ### orthoprojplane3d ### 
%% Projection orthogonale d'un point 3d sur un plan
%% Mx My Mz (=le point a projeter) 
%% Ax Ay Az (=un point du plan) 
%% Vx Vy Vz (un vecteur normal au plan)
/orthoprojplane3d { 
4 dict begin
   dup isplan {
      /monplan exch def
      monplan plangetorigine
      monplan plangetbase aload pop vectprod3d
   } if
   /V defpoint3d
   /A defpoint3d
   /M defpoint3d
   /VN {V unitaire3d} def
   VN M A vecteur3d VN scalprod3d mulv3d
   M addv3d
end
} def

%%%%% ### sortp3d ### 
/sortp3d {
6 dict begin
   /M1 defpoint3d
   /M0 defpoint3d
   M1
   /z1 exch def
   /y1 exch def
   /x1 exch def
   M0
   /z0 exch def
   /y0 exch def
   /x0 exch def
   x0 x1 lt {
      M0 M1
   } {
      x0 x1 gt {
         M1 M0
      } {
         y0 y1 lt {
            M0 M1
         } {
            y0 y1 gt {
               M1 M0
            } {
               z0 z1 lt {
                  M0 M1
               } {
                  M1 M0
               } ifelse
            } ifelse
         } ifelse
      } ifelse
   } ifelse
end
} def

%%%%% ### dupp3d ### 
%% duplique le vecteur 3d
/dupp3d { %% x y z
        3 copy
} def
/dupv3d {dupp3d} def

%%%%% ### angle3d ###
%% syntaxe : vect1 vect2 angle3d
/angle3d {
4 dict begin
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d norme3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### transformpoint3d ###
%% syntaxe : x y z a11 a21 a31 a12 a22 a32 a13 a23 a33
%%    transformpoint3d -> X Y Z
/transformpoint3d {
12 dict begin
   /a33 exch def
   /a23 exch def
   /a13 exch def
   /a32 exch def
   /a22 exch def
   /a12 exch def
   /a31 exch def
   /a21 exch def
   /a11 exch def
   /z   exch def
   /y   exch def
   /x   exch def
   a11 x mul a12 y mul add a13 z mul add
   a21 x mul a22 y mul add a23 z mul add
   a31 x mul a32 y mul add a33 z mul add
end
} def

%%%%% ### normalize3d ###
%% rend le vecteur 3d unitaire. Ne fait rien si u=0
/unitaire3d { %% x y z
2 dict begin
   /u defpoint3d
   /norme u norme3d def
   norme 0 eq {
      u
   } {
      u 1 norme div mulv3d
   } ifelse
end
} def
/normalize3d {unitaire3d} def

%%%%% ### geom3d ###
%% syntaxe : A k1 B k2 barycentre3d -> G, barycentre du systeme
%% [(A, k1) (B, k2)]
/barycentre3d {
4 dict begin
   /k2 exch def
   /B defpoint3d
   /k1 exch def
   /A defpoint3d
   A k1 mulv3d
   B k2 mulv3d
   addv3d
   1 k1 k2 add div mulv3d
end
} def

%% syntaxe : array isobarycentre3d --> G
/isobarycentre3d {
2 dict begin
   /table exch def
   /n table length 3 idiv def
   table 0 getp3d
   1 1 n 1 sub {
       table exch getp3d
       addv3d
   } for
   1 n div mulv3d
end
} def

%% syntaxe : M A alpha hompoint3d -> le point M' tel que AM' = alpha AM 
/hompoint3d {
3 dict begin
   /alpha exch def
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d alpha mulv3d A addv3d
end
} def

%% syntaxe : M A sympoint3d -> le point M' tel que AM' = -AM
/sympoint3d {
2 dict begin
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d -1 mulv3d A addv3d
end
} def

%% syntaxe : A u translatepoint3d --> B image de A par la translation de vecteur u
/translatepoint3d {
   addv3d
} def

/scaleOpoint3d {
6 dict begin
   /k3 exch def
   /k2 exch def
   /k1 exch def
   /z exch def
   /y exch def
   /x exch def
   k1 x mul
   k2 y mul
   k3 z mul
end
} def

% syntaxe : M alpha_x alpha_y alpha_z rotateOpoint3d --> M'
/rotateOpoint3d {
21 dict begin
   /RotZ exch def
   /RotY exch def
   /RotX exch def
   /Zpoint exch def
   /Ypoint exch def
   /Xpoint exch def
   /c1 {RotX cos} bind def
   /c2 {RotY cos} bind def
   /c3 {RotZ cos} bind def
   /s1 {RotX sin} bind def
   /s2 {RotY sin} bind def
   /s3 {RotZ sin} bind def
   /M11 {c2 c3 mul} bind def
   /M12 {c3 s1 mul s2 mul c1 s3 mul sub} bind def
   /M13 {c1 c3 mul s2 mul s1 s3 mul add} bind def
   /M21 {c2 s3 mul} bind def
   /M22 {s1 s2 mul s3 mul c1 c3 mul add} bind def
   /M23 {s3 s2 mul c1 mul c3 s1 mul sub} bind def
   /M31 {s2 neg} bind def
   /M32 {s1 c2 mul} bind def
   /M33 {c1 c2 mul} bind def
   RotSequence (zyx) eq {
    /M11 {c2 c3 mul} bind def
    /M12 {c2 s3 mul neg} bind def
    /M13 {s2} bind def
    /M21 {s1 s2 mul c3 mul c1 s3 mul add} bind def
    /M22 {s1 s2 mul s3 mul neg c1 c3 mul add} bind def
    /M23 {s1 c2 mul neg} bind def
    /M31 {c1 s2 mul c3 mul neg s1 s3 mul add} bind def
    /M32 {c1 s2 mul s3 mul s1 c3 mul add} bind def
    /M33 {c1 c2 mul} bind def
    } if
   RotSequence (yzx) eq {
    /M11 {c2 c3 mul} bind def
    /M12 {s3 neg} bind def
    /M13 {s2 c3 mul} bind def
    /M21 {c1 s3 mul c2 mul s1 s2 mul add} bind def
    /M22 {c1 c3 mul} bind def
    /M23 {c1 s2 mul s3 mul s1 c2 mul sub} bind def
    /M31 {s1 c2 mul s3 mul c1 s2 mul sub} bind def
    /M32 {s1 c3 mul} bind def
    /M33 {s1 s2 mul s3 mul c1 c2 mul add} bind def
    } if
  RotSequence (zxy) eq {
  /M11 {c2 c3 mul s1 s2 mul s3 mul add} bind def
  /M12 {c2 s3 mul neg s1 s2 mul c3 mul add} bind def
  /M13 {c1 s2 mul} bind def
  /M21 {c1 s3 mul} bind def
  /M22 {c1 c3 mul} bind def
  /M23 {s1 neg} bind def
  /M31 {s2 c3 mul neg s1 c2 mul s3 mul add} bind def
  /M32 {s2 s3 mul s1 c2 mul c3 mul add} bind def
  /M33 {c1 c2 mul} bind def
  } if
 RotSequence (xzy) eq {
  /M11 {c2 c3 mul} bind def
  /M12 {c1 s3 mul c2 mul neg s1 s2 mul add} bind def
  /M13 {s1 c2 mul s3 mul c1 s2 mul add} bind def
  /M21 {s3} bind def
  /M22 {c1 c3 mul} bind def
  /M23 {s1 c3 mul neg} bind def
  /M31 {s2 c3 mul neg} bind def
  /M32 {c1 s2 mul s3 mul s1 c2 mul add} bind def
  /M33 {s1 s2 mul s3 mul neg c1 c2 mul add} bind def
 } if
 RotSequence (yxz) eq {
  /M11 {c2 c3 mul s1 s2 mul s3 mul sub} bind def
  /M12 {c1 s3 mul neg} bind def
  /M13 {s2 c3 mul s1 c2 mul s3 mul add} bind def
  /M21 {c2 s3 mul s1 s2 mul c3 mul add} bind def
  /M22 {c1 c3 mul} bind def
  /M23 {s2 s3 mul s1 c2 mul c3 mul sub} bind def
  /M31 {c1 s2 mul neg} bind def
  /M32 {s1} bind def
  /M33 {c1 c2 mul} bind def
  } if
 RotSequence (xyz) eq {
  /M11 {c2 c3 mul} bind def
  /M12 {c1 s3 mul neg s1 s2 mul c3 mul add} bind def
  /M13 {s1 s3 mul c1 s2 mul c3 mul add} bind def
  /M21 {c2 s3 mul} bind def
  /M22 {c1 c3 mul s1 s2 mul s3 mul add} bind def
  /M23 {s1 c3 mul neg c1 s2 mul s3 mul add} bind def
  /M31 {s2 neg} bind def
  /M32 {s1 c2 mul} bind def
  /M33 {c1 c2 mul} bind def
 } if
   M11 Xpoint mul M12 Ypoint mul add M13 Zpoint mul add
   M21 Xpoint mul M22 Ypoint mul add M23 Zpoint mul add
   M31 Xpoint mul M32 Ypoint mul add M33 Zpoint mul add
end
} def

%%%%% ### symplan3d ###
%% syntaxe : M eqplan/plantype symplan3d --> M'
%% ou M' symetrique de M par rapport au plan P defini par eqplan/plantype
/symplan3d {
13 dict begin
   dup isplan {
      plan2eq /args exch def
   } {
      /args exch def
   } ifelse
   /z exch def
   /y exch def
   /x exch def
   args aload pop
   /d1 exch def
   /c1 exch def
   /b1 exch def
   /a1 exch def
   /n_U a1 dup mul b1 dup mul add c1 dup mul add sqrt def
   /a a1 n_U div def
   /b b1 n_U div def
   /c c1 n_U div def
   /d d1 n_U div def
   /u a x mul b y mul add c z mul add d add def
   x 2 a mul u mul sub
   y 2 b mul u mul sub
   z 2 c mul u mul sub
end
} def

%%%%% ### vecteur3d ###
%% creation du vecteur AB a partir de A et B
/vecteur3d { %% xA yA zA xB yB zB
6 dict begin
   /zB exch def
   /yB exch def
   /xB exch def
   /zA exch def
   /yA exch def
   /xA exch def
   xB xA sub
   yB yA sub
   zB zA sub
end
}def

%%%%% ### vectprod3d ###
%% produit vectoriel de deux vecteurs 3d
/vectprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub
end
} def

%%%%% ### scalprod3d ###
%% produit scalaire de deux vecteurs 3d
/scalprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp mul y yp mul add z zp mul add
end
} def

%%%%% ### papply3d ###
%% syntaxe : [A1 ... An] (f) papply3d --> [f(A1) ... f(An)]
/papply3d {
3 dict begin
   /fonction exch def
   /liste exch def
   /i 0 def
   [
   liste length 3 idiv {
      liste i get
      liste i 1 add get
      liste i 2 add get
      fonction
      /i i 3 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### defpoint3d ###
%% creation du point A a partir de xA yA yB et du nom /A
/defpoint3d { %% xA yA zA /nom
1 dict begin
   /memo exch def
   [ 4 1 roll ] cvx memo exch
end def
}def

%%%%% ### distance3d ###
/distance3d { %% A B
   vecteur3d norme3d
} def

%%%%% ### get3d ###
/getp3d { %% [tableau de points 3d] i --> donne le ieme point du tableau
   2 copy 2 copy
   3 mul get
   5 1 roll
   3 mul 1 add get
   3 1 roll
   3 mul 2 add get
} def

%%%%% ### norme3d ###
%% norme d un vecteur 3d
/norme3d { %% x y z
3 dict begin
   /z exch def
   /y exch def
   /x exch def
   x dup mul y dup mul add z dup mul add sqrt
end
} def

%%%%% ### mulv3d ###
%% (scalaire)*(vecteur 3d) Attention : dans l autre sens !
/mulv3d { %% x y z lambda
4 dict begin
   /lambda exch def
   /z exch def
   /y exch def
   /x exch def
   x lambda mul
   y lambda mul
   z lambda mul
end
} def

%%%%% ### addv3d ###
%% addition de deux vecteurs 3d
/addv3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp add
   y yp add
   z zp add
end
} def

%%%%% ### milieu3d ###
/milieu3d { %% A B --> I le milieu de [AB]
   addv3d 0.5 mulv3d
} def

%%%%% ### exch ###
/exchp {
   4 -1 roll
   4 -1 roll
} def
/exchc {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def
/exchd {
   4 {8 -1 roll} repeat
} def
/exchp3d {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def

%%%%% ### ABpoint3d ###
%% syntaxe : A B k ABpoint3d --> M
%% M tel que vect(AM) = k vect (AB)
/ABpoint3d {
3 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   k mulv3d
   A addv3d 
end
} def

%%%%% ### angle3doriente ###
%% syntaxe : vect1 vect2 vect3 angle3d
%% vect3 est la normale au plan (vect1, vect2)
/angle3doriente {
4 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d vect3 scalprod3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### points3dalignes ###
%% syntaxe : A B C points3dalignes -> bool
/points3dalignes {
3 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d /u defpoint3d
   A C vecteur3d /v defpoint3d
   u v vectprod3d norme3d 1E-7 lt
end
} def

%% syntaxe : M A B point3dsursegment --> true si M in [AB], false sinon
/point3dsursegment {
3 dict begin
   /B defpoint3d
   /A defpoint3d
   /M defpoint3d
   M A B points3dalignes {
      M A vecteur3d
      M B vecteur3d
      scalprod3d 0 lt {
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (dessins)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### point3d ###
/point3d { %% A
   3dto2d point
} def

/points3d { %% tableau de points3d
   tab3dto2d points
} def

%%%%% ### ligne3d ###
%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne
end
} def

%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d_ { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne_
end
} def

%%%%% ### tab3dto2d ###
%% transforme un tableau de points 3d en tableau de points 2d
/tab3dto2d {
2 dict begin
   /T exch def
   /n T length def
   [ T aload pop
   n 1 sub -1 n 3 idiv 2 mul
   { 1 dict begin
   /i exch def
   3dto2d i 2 roll
   end } for ]
end
} def

%%%%% ### polygone3d ###
/polygone3d { %% tableau de points3d
   tab3dto2d polygone
} def

/polygone3d* { %% tableau de points3d
   tab3dto2d polygone*
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 gestion du texte                   %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### marks ###
/xmkstep 1 def          % les marques sur Ox
/xmarkstyle {dctext} def
/ymarkstyle {(-1 0) bltext} def
/setxmkstep {
   /xmkstep exch def
} def
/xmark {
   dup xtick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup dup truncate eq {
      cvi dup chaine cvs exch 
   } {
      dup chaine cvs exch 
   } ifelse
   Oy xmarkstyle
} def
/xmarks {
2 dict begin
   /n xmax xmax xmin sub 1000 div sub xmkstep div truncate cvi 
      xmkstep mul def                   % mark max
   /i xmin xmkstep div truncate cvi 
      xmkstep mul def                   % la 1ere
   i xmin lt {/i i xmkstep add store} if
   {
      i 0 ne {i xmark} if
      /i i xmkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/ymkstep 1 def          % les marques sur Oy
/setymkstep {
   /ymkstep exch def
} def
/ymark {
   dup ytick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup chaine cvs exch 
   Ox exch ymarkstyle
} def
/ymarks {
2 dict begin
   /n ymax ymax ymin sub 1000 div sub ymkstep div truncate cvi 
      ymkstep mul def                   % mark max
   /i ymin ymkstep div truncate cvi 
      ymkstep mul def                   % la 1ere
   {
      i 0 ne {i ymark} if
      /i i ymkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/setmkstep {
   setymkstep
   setxmkstep
} def
/marks {
   xmarks
   ymarks
} def

%%%%% ### setfontsize ###
/setfontsize {
   /fontsize exch def
} def

%%%%% ### setCourrier ###
/Courier findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end

/Courier-ISOLatin1 exch definefont pop

/setCourier {
   /Courier-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

%%%%% ### pathtext ###
%% syntaxe : string x y initp@thtext
 /initp@thtext {
7 dict begin
   /y exch def
   /x exch def
   /str exch def
   str 0 0 show_dim
   /wy exch def
   /wx exch def
   /lly exch def
   /llx exch def
   pop pop pop
   newpath 
      x y  smoveto
} def
 /closep@thtext {
      str true charpath
end
} def

%% syntaxe : string x y cctext_
/cctext_ {
   initp@thtext
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

/brtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg 0 rmoveto
   closep@thtext
} def

/bbtext_ {
   initp@thtext
   0 0 rmoveto
   0 0 rmoveto
   closep@thtext
} def

/bltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg 0 rmoveto
   closep@thtext
} def

/bctext_ {
   initp@thtext
   0 0 rmoveto
   wx llx add -.5 mul 0 rmoveto
   closep@thtext
} def

/ubtext_ {
   initp@thtext
   0 vadjust rmoveto
   0 lly neg rmoveto
   closep@thtext
} def

/urtext_ {
   initp@thtext
   hadjust vadjust rmoveto
   llx neg lly neg rmoveto
   closep@thtext
} def

/ultext_ {
   initp@thtext
   hadjust neg vadjust rmoveto
   wx neg lly neg rmoveto
   closep@thtext
} def

/uctext_ {
   initp@thtext
   0 vadjust rmoveto
   llx wx add -.5 mul lly neg rmoveto
   closep@thtext
} def

/drtext_ {
   initp@thtext
   hadjust vadjust neg rmoveto
   llx neg wy neg rmoveto
   closep@thtext
} def

/dbtext_ {
   initp@thtext
   0 vadjust neg rmoveto
   0 wy neg rmoveto
   closep@thtext
} def

/dltext_ {
   initp@thtext
   hadjust neg vadjust neg rmoveto
   wx neg wy neg rmoveto
   closep@thtext
} def

/dctext_ {
   initp@thtext
   0 vadjust neg rmoveto
   llx wx add -2 div wy neg rmoveto
   closep@thtext
} def

/crtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cbtext_ {
   initp@thtext
   0 0 rmoveto
   0 lly wy add -2 div rmoveto
   closep@thtext
} def

/cltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cctext_ {
   initp@thtext
   0 0 rmoveto
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

%%%%% ### text3d ###
%%%% Version 3d des commandes jps TEXTE
 /pr@p@re3d {
2 dict begin
%   /vect_echelle [1 1] def
%   /angle_de_rot {0} def
%   dup xcheck
%      {/angle_de_rot exch def}
%   if
%   dup isarray
%      {/vect_echelle exch def}
%   if%   CamView vect_echelle {angle_de_rot}
   3dto2d
} def

/bbtext3d {
   pr@p@re3d
   bbtext
end
} def

/bbtexlabel3d {
   pr@p@re3d
   bbtexlabel
end
} def

/bctext3d {
   pr@p@re3d
   bctext
end
} def

/bctexlabel3d {
   pr@p@re3d
   bctexlabel
end
} def

/bltext3d {
   pr@p@re3d
   bltext
end
} def

/bltexlabel3d {
   pr@p@re3d
   bltexlabel
end
} def

/brtext3d {
   pr@p@re3d
   brtext
end
} def

/brtexlabel3d {
   pr@p@re3d
   brtexlabel
end
} def

/cbtext3d {
   pr@p@re3d
   cbtext
end
} def

/cbtexlabel3d {
   pr@p@re3d
   cbtexlabel
end
} def

/cctext3d {
   pr@p@re3d
   cctext
end
} def

/cctexlabel3d {
   pr@p@re3d
   cctexlabel
end
} def

/cltext3d {
   pr@p@re3d
   cltext
end
} def

/cltexlabel3d {
   pr@p@re3d
   cltexlabel
end
} def

/crtext3d {
   pr@p@re3d
   crtext
end
} def

/crtexlabel3d {
   pr@p@re3d
   crtexlabel
end
} def

/dbtext3d {
   pr@p@re3d
   dbtext
end
} def

/dbtexlabel3d {
   pr@p@re3d
   dbtexlabel
end
} def

/dctext3d {
   pr@p@re3d
   dctext
end
} def

/dctexlabel3d {
   pr@p@re3d
   dctexlabel
end
} def

/dltext3d {
   pr@p@re3d
   dltext
end
} def

/dltexlabel3d {
   pr@p@re3d
   dltexlabel
end
} def

/drtext3d {
   pr@p@re3d
   drtext
end
} def

/drtexlabel3d {
   pr@p@re3d
   drtexlabel
end
} def

/ubtext3d {
   pr@p@re3d
   ubtext
end
} def

/ubtexlabel3d {
   pr@p@re3d
   ubtexlabel
end
} def

/uctext3d {
   pr@p@re3d
   uctext
end
} def

/uctexlabel3d {
   pr@p@re3d
   uctexlabel
end
} def

/ultext3d {
   pr@p@re3d
   ultext
end
} def

/ultexlabel3d {
   pr@p@re3d
   ultexlabel
end
} def

/urtext3d {
   pr@p@re3d
   urtext
end
} def

/urtexlabel3d {
   pr@p@re3d
   urtexlabel
end
} def

%%%%% ### fin insertion ###

%% La macro provisoire de developpement (27/01/2009)
%% syntaxe : solid table tablez --> -
/solidcolorz {
10 dict begin
   %% les hauteurs
   /tablez exch def
   %% les couleurs
   /usertable exch def
   /solid exch def
   %% a-t-on des couleurs nommees ?
   usertable 0 get isstring {
      %% oui, et autant que d etages
      usertable length 1 sub tablez length eq {
         /table usertable def
      } {
         %% oui, mais moins que d etages
	 %% ==> on definit les 2 premieres en RGB
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         /lacouleurdepart {
            gsave
               [a0 cvx exec] length 0 eq {
                  a0 cvx exec currentrgbcolor
               } {
                  a0 cvx exec
               } ifelse 
            grestore
         } def
         /lacouleurarrivee {
            gsave
               [a1 cvx exec] length 0 eq {
                  a1 cvx exec currentrgbcolor
               } {
                  a1 cvx exec
               } ifelse 
            grestore
         } def
         /usertable [lacouleurdepart lacouleurarrivee] def
      } ifelse
   } if
   usertable 0 get isnum {
      %% c est un degrade : nb de couleurs a definir
      /n tablez length 1 add def
%      
      usertable length 4 eq {
          /a0 usertable 0 get def
          /a1 usertable 1 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B usertable 2 get def
          /C usertable 3 get def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%      
      usertable length 6 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (setrgbcolor) def
      } if
%
      usertable length 7 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%   
      usertable length 8 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /d0 usertable 3 get def
          /a1 usertable 4 get def
          /b1 usertable 5 get def
          /c1 usertable 6 get def
          /d1 usertable 7 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {d0 i d1 d0 sub mul n 1 sub div add} def
          /espacedecouleurs (setcmykcolor) def
      } if
%
      usertable length 2 eq {
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         0 1 n 1 sub {
            /i exch def
            /A {a0 i a1 a0 sub mul n 1 sub div add} def
            /B {1} def
            /C {1} def
            /D {} def
            /espacedecouleurs (sethsbcolor) def
         } for
      } if
%
      %% on affecte la table des couleurs
      /table [
         0 1 n 1 sub {
            /i exch def
            [A B C D] espacedecouleurs astr2str
         } for
      ] def
   } if
%
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /z exch def pop pop
      /resultat 0 def
      0 1 tablez length 1 sub {
         /j exch def
         /ztest tablez j get def
         z ztest le {
	    /resultat j store
            exit
         } {
	    /resultat j 1 add store
	 } ifelse
      } for
      solid i table resultat get solidputfcolor
   } for
end
} def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             bibliotheque sur les solides           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solide ###
%% solid = [Sommets Faces Colors_Faces InOut_Table]
/solidgetsommets {
   0 get
} def
/solidgetpointstable {solidgetsommets} def

/solidgetfaces {
   1 get
} def

/solidgetface {
1 dict begin
   /i exch def
   solidgetfaces i get
end
} def

/solidgetfcolors {
   2 get
} def

%% syntaxe : solid i solidgetfcolor --> str
/solidgetfcolor {
1 dict begin
   /i exch def
   solidgetfcolors i get
end
} def

%% syntaxe : solid i str solidputfcolor --> -
/solidputfcolor {
2 dict begin
   /str exch def
   /i exch def
   solidgetfcolors i str put
end
} def

/solidgetinouttable {
   3 get
} def

/solidputsommets {
   0 exch put
} def
/solidputpointstable {solidputsommets} def

/solidputfaces {
   1 exch put
} def

%% syntaxe : solid solidfacesreverse -> -
/solidfacesreverse {
5 dict begin
   /solid exch def
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      /F solid i solidgetface reverse def
      /m F length def
      solid i [F aload pop m 0 roll ] solidputface
   } for
end
} def

/solidputfcolors {
   2 exch put
} def

/solidputinouttable {
   3 exch put
} def

%% syntaxe : any issolid --> booleen, vrai si any est de type solid
/issolid {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 4 eq {
         candidat 0 get isarray
         candidat 1 get isarray and
         candidat 2 get isarray and
         candidat 3 get isarray and {
            /IO candidat 3 get def
            IO length 4 eq 
            IO 0 get isnum and
            IO 1 get isnum and
            IO 2 get isnum and
            IO 3 get isnum and
	 } {
	    false
	 } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/dupsolid {
5 dict begin
   /solid exch def
   /S solid solidgetsommets def
   /F solid solidgetfaces def
   /FC solid solidgetfcolors def
   /IO solid solidgetinouttable def
   solid
   [
      S duparray exch pop
      F duparray exch pop
      FC duparray exch pop
      IO duparray exch pop
   ]
end
} def

%% syntaxe : solid array solidputinfaces --> -
/solidputinfaces {
4 dict begin
   /facesinternes exch def
   /solid exch def
   /n2 facesinternes length def
   /IO solid solidgetinouttable def
   /facesexternes solid solidgetoutfaces def
   /n1 facesexternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

%% syntaxe : solid array solidputoutfaces --> -
/solidputoutfaces {
4 dict begin
   /facesexternes exch def
   /solid exch def
   /n1 facesexternes length def
   /IO solid solidgetinouttable def
   /facesinternes solid solidgetinfaces def
   /n2 facesinternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

/solidnombreinfaces {
1 dict begin
   /solid exch def
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get IO 2 get sub 1 add
   } {
      0
   } ifelse
end
} def

/solidnombreoutfaces {
1 dict begin
   /solid exch def
   /IO solid solidgetinouttable def
   IO 1 get IO 0 get sub 1 add
end
} def

%% syntaxe : solid solidgetinfaces --> array
/solidgetinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      /F solid solidgetfaces def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      F n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutfaces --> array
/solidgetoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutfaces) ==
      quit
   } if
   /IO solid solidgetinouttable def
   /F solid solidgetfaces def
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   F n1 n getinterval
end
} def

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def

/solidgridOn { 
   /solidgrid true def
} def
/solidgridOff {
   /solidgrid false def
} def

%% syntaxe : solid i string solidputfcolor
%% syntaxe : solid str outputcolors
%% syntaxe : solid str1 str2 inoutputcolors
%% syntaxe : solid string n solidputncolors
%% syntaxe : solid array solidputincolors --> -
%% syntaxe : solid array solidputoutcolors --> -
%% syntaxe : solid solidgetincolors --> array
%% syntaxe : solid solidgetoutcolors --> array

%% syntaxe : solid array solidputinfaces --> -
%% syntaxe : solid array solidputoutfaces --> -
%% syntaxe : solid solidgetinfaces --> array
%% syntaxe : solid solidgetoutfaces --> array

%% syntaxe : solid1 solid2 solidfuz -> solid

%% syntaxe : solid i solidgetsommetsface -> array
%% array = tableau de points 3d
/solidgetsommetsface {
1 dict begin
   /i exch def
   /solid exch def
   /F solid i solidgetface def
   [
      0 1 F length 1 sub {
         /k exch def
         solid F k get solidgetsommet
      } for
   ]
end
} def

%% syntaxe : solid index table solidputface -> -
/solidputface {
1 dict begin
   /table exch def
   /i exch def
   solidgetfaces i table put
end
} def

%% syntaxe : solid table solidaddface -> -
%% syntaxe : solid table (couleur) solidaddface -> -
%% on ne se preoccupe pas des faces internes
/solidaddface {
6 dict begin
   dup isstring {
      /lac@uleur exch def
   } {
      /lac@uleur () def
   } ifelse
   /table exch def
   /solid exch def
   /IO solid solidgetinouttable def
   /n2 IO 1 get def
   /FC solid solidgetoutcolors def
   IO 1 n2 1 add put
   solid [ solid solidgetfaces aload pop table ] solidputfaces
   solid IO solidputinouttable
%   solid solidnombrefaces
    solid [
      FC aload pop lac@uleur
    ] solidputoutcolors
end
} def

/solidnombrefaces {
1 dict begin
   /solid exch def
   solid solidnombreinfaces
   solid solidnombreoutfaces
   add 
end
} def

%% syntaxe : solid M solidaddsommetexterne -> -
%% on ajoute le sommet sans se preoccuper de rien
/solidaddsommetexterne {
2 dict begin
   /M defpoint3d
   /solid exch def
   solid
   [ solid solidgetsommets aload pop M ]
   solidputsommets
end
} def

%% syntaxe : solid array solidaddsommets -> -
/solidaddsommets {
2 dict begin
   /table exch def
   /solid exch def
   /n table length 3 idiv def
   0 1 0 {
      /i exch def
      solid table i getp3d solidaddsommet pop
   } for
end
} def

%% syntaxe : solid M solidaddsommet -> k
%% on ajoute le sommet M. Si il est deja sur une arete,
%% on l incorpore a la face concernee 
%% s il est deja present, on ne le rajoute pas.
%% Renvoie l indice du sommet rajoute.
/solidaddsommet {
10 dict begin
   /M defpoint3d
   /solid exch def
   /nbf solid solidnombrefaces def
   /N solid solidnombresommets def
   /sortie -1 def
   %% le sommet est-il deja dans la structure
   0 1 N 1 sub {
      /i exch def
%%       (addsommet) ==
%%       solid i solidgetsommet == == == 
%%       M == == ==
%%       solid i solidgetsommet M eqp3d ==
   
%      solid i solidgetsommet M eqp3d {
      solid i solidgetsommet M distance3d 1e-5 le {
         %% oui => c est fini
         /sortie i store
      } if
   } for
   sortie 0 lt {
      %% non => on le rajoute
      /sortie N def
      solid M solidaddsommetexterne
      %% est il sur une arete deja codee
      0 1 nbf 1 sub {
         %% face d indice i
         /i exch def
         solid i solidgetface /F exch def
         /nbsf F length def
         0 1 nbsf 1 sub {
            /j exch def
            M
            solid j i solidgetsommetface 
            solid j 1 add nbsf mod i solidgetsommetface 
            point3dsursegment {
               %% il est sur l arete concernee
               solid i [
                  0 1 j {
                     /k exch def
                     F k get
                  } for
                  N
                  j 1 add nbsf mod dup 0 eq {
                     pop
                  } {
                     1 nbsf 1 sub {
                        /k exch def
                        F k get
                     } for
                  } ifelse
               ]  solidputface
               exit
            } if
         } for 
      } for
   } if
   sortie
end
} def

%%%%% ### solidrmsommet ###
%% syntaxe : solid i solidrmsommet -> -
/solidrmsommet {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidrmsommet) ==
      quit 
   } if
   solid i solidsommetsadjsommet length 0 gt {
      (Erreur : sommet non isole dans solidrmsommet) ==
      quit 
   } if

   %% on s occupe des sommets
   /n solid solidnombresommets def
   /S [
      0 1 n 1 sub {
         /j exch def
         j i ne {
            solid j solidgetsommet
         } if
      } for
   ] def
   solid S solidputsommets
   %% on s occupe des faces
   /n solid solidnombrefaces def
   /F [
      0 1 n 1 sub {
         %% face d indice j
         /j exch def
         /Fj solid j solidgetface def
         [0 1 Fj length 1 sub {
            %% sommet d indice k de la face Fj
            /k exch def
            Fj k get dup i gt {
               1 sub
            } if
         } for]
      } for
   ] def
   solid F solidputfaces
end
} def

%%%%% ### solidsommetsadjsommet ###
%% syntaxe : solid i solidsommetsadjsommet --> array
%% array est le tableau des indices des sommets adjacents au
%% sommet d indice i
/solidsommetsadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   solid no solidfacesadjsommet /facesadj exch def
   /sommetsadj [] def
   /nbadj facesadj length def
   0 1 nbadj 1 sub {
      /j exch def
      %% examen de la jieme face
      %/j 0 def
      /F solid facesadj j get solidgetface def
      /nbsommetsface F length def
      no F in {
         /index exch def
         /i1 F index 1 sub nbsommetsface modulo get def
         /i2 F index 1 add nbsommetsface mod get def
         %% si i1 n est pas deja note, on le rajoute
         i1 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i1 ] store
         } ifelse
         %% si i2 n est pas deja note, on le rajoute
         i2 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i2 ] store
         } ifelse
      } {
         (Error : bug dans solidsommetsadjsommet) ==
         quit
      } ifelse
   } for
   sommetsadj
end
} def

%%%%% ### solidfacesadjsommet ###
%% syntaxe : solid i solidfacesadjsommet --> array
%% array est le tableau des indices des faces adjacentes au
%% sommet d indice i
/solidfacesadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   /n solid solidnombrefaces def
   /indicesfacesadj [] def
   0 1 n 1 sub {
      /j exch def
      /F solid j solidgetface def
      no F in {
         pop
         /indicesfacesadj [ indicesfacesadj aload pop j ] store
      } if
   } for
   indicesfacesadj
end
} def

%%%%% ### ordonnepoints3d ###
%% syntaxe : array1 M ordonnepoints3d --> array2
%% array1 = tableau de points 3d coplanaires (plan P)
%% M = point3d indiquant la direction de la normale a P
%% array2 = les indices des points de depart, ranges dans le 
%% sens trigo par rapport a la normale
/ordonnepoints3d {
5 dict begin
   /M defpoint3d
   /table exch def
   table isobarycentre3d /G defpoint3d
   %% calcul de la normale
   table 0 getp3d /ptref defpoint3d
   table 1 getp3d /A defpoint3d
   G ptref vecteur3d
   G A vecteur3d
   vectprod3d /vecteurnormal defpoint3d
   vecteurnormal G M vecteur3d scalprod3d 0 lt {
      vecteurnormal -1 mulv3d /vecteurnormal defpoint3d
   } if
   %% la table des angles
   table duparray exch pop
   {1 dict begin
      /M defpoint3d
      G ptref vecteur3d
      G M vecteur3d
      vecteurnormal angle3doriente
   end} papply3d
%   [0 1 table length 3 idiv 1 sub {} for]
%   exch
    doublebubblesort pop
end
} def

%%%%% ### fin insertion ###

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% 
%% /solidgrid true def
%% /aretescachees true def
%% /defaultsolidmode 2 def

%% syntaxe : alpha beta r h newpie --> solid
/newpie {
6 dict begin
   [[/resolution /nbetages] [8 1] [10 1] [12 1] [18 3] [36 5]] gestionsolidmode
   /h exch def
   /r exch def
   /beta exch def
   /alpha exch def
   [
      0 0
%      alpha cos r mul alpha sin r mul
      alpha beta {1 dict begin /t exch def t cos r mul t sin r mul end} CourbeR2+
   ] 0 h [nbetages] newprismedroit
end
} def

%%%%% ### newsolid ###
%% syntaxe : newsolid --> depose le solide nul sur la pile
/newsolid {
   [] [] generesolid
} def

%%%%% ### generesolid ###
/generesolid {
2 dict begin
   /F exch def
   /S exch def
   [S F [F length {()} repeat] [0 F length 1 sub -1 -1]]
end
} def

%%%%% ### nullsolid ###
%% syntaxe : solide nullsolid -> booleen, vrai si le solide est nul
/nullsolid {
1 dict begin
   /candidat exch def
   candidat issolid not {
      (Error type argument dans "nullsolid") ==
      quit
   } if
   candidat solidgetsommets length 0 eq {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidnombreoutfaces ###
/solidnombreoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreoutfaces) ==
      quit
   } if
   solid nullsolid {
      0
   } {
      /IO solid solidgetinouttable def
      IO 1 get
      IO 0 get sub
      1 add
   } ifelse
end
} def

%%%%% ### solidnombreinfaces ###
/solidnombreinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get
      IO 2 get sub
      1 add
   } {
      0
   } ifelse
end
} def

%%%%% ### solidtests ###
%% syntaxe : solid solidwithinfaces --> bool, true si le solide est vide
/solidwithinfaces {
2 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidwithinfaces) ==
      quit
   } if
   /table solid solidgetinouttable def
   table 2 get -1 ne {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidgetsommet ###
%% syntaxe : solid i j solidgetsommetface --> sommet i de la face j
/solidgetsommetface {
6 dict begin
   /j exch def
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /k table_faces j get i get def
   table_sommets k getp3d
end
} def

%% syntaxe : solid i solidgetsommetsface --> array, tableau des
%% sommets de la face i du solide
/solidgetsommetsface {
6 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetsface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /table_indices table_faces i get def
   [
      0 1 table_indices length 1 sub {
         /j exch def
         table_sommets table_indices j get getp3d
      } for
   ]
end
} def

%% syntaxe : solid i solidgetsommet --> sommet i du solide
/solidgetsommet {
3 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommet) ==
      quit
   } if
   /table_sommets solid solidgetsommets def
   table_sommets i getp3d
end
} def

%%%%% ### solidcentreface ###
%% syntaxe : solid i solidcentreface --> M
/solidcentreface {
   solidgetsommetsface isobarycentre3d
} def

%%%%% ### solidnombre ###
/solidnombresommets {
   solidgetsommets length 3 idiv
} def

/solidfacenombresommets {
   solidgetface length
} def

/solidnombrefaces {
   solidgetfaces length
} def

%%%%% ### solidshowsommets ###
/solidshowsommets {
8 dict begin
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      sol i solidgetsommet point3d
   } for
end
} def

%%%%% ### solidnumsommets ###
/solidnumsep 15 def
/solidnumsommets {
8 dict begin
%   Font findfont 10 scalefont setfont
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   /result [
      n {false} repeat
   ] def
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      0 1 m 1 sub {
         /j exch def %% indice de la face examinee
         i sol j solidgetface in {
            %% le sommet i est dans la face j
            pop
            exit
         } if
      } for
      sol i solidgetsommet /S defpoint3d
      i (   ) cvs
      m 0 ne {
         %% le sommet i est dans la face j
         sol j solidcentreface /G defpoint3d
         G S vecteur3d normalize3d
         solidnumsep dup ptojpoint pop
         mulv3d
         S addv3d
         3dto2d cctext 
      } {
         S 3dto2d uctext
      } ifelse
   } for
end
} def

%%%%% ### gestionsolidmode ###
%% table = [ [vars] [mode0] [mode1] [mode2] [mode3] [mode4] ]
/gestionsolidmode {
5 dict begin
   /table exch def
   dup xcheck {
      /mode exch def
   } {
      dup isarray {
         /tableaffectation exch def
         /mode -1 def
      } {
         /mode defaultsolidmode def
      } ifelse
   } ifelse
   /vars table 0 get def
   /nbvars vars length def
   mode 0 ge {
      /tableaffectation table mode 1 add 5 min get def
   } if
   0 1 nbvars 1 sub {
      /i exch def
      vars i get
      tableaffectation i get
   } for
   nbvars 
end
   {def} repeat
} def

%%%%% ### solidfuz ###
%% syntaxe : solid1 solid2 solidfuz -> solid
/solidfuz {
5 dict begin
   /solid2 exch def
   /solid1 exch def
   /S1 solid1 solidgetsommets def
   /S2 solid2 solidgetsommets def
   /n S1 length 3 idiv def

   %% les sommets
   /S S1 S2 append def

   %% les faces internes et leurs couleurs
   /FI1 solid1 solidgetinfaces def
   /FIC1 solid1 solidgetincolors def
   solid2 solidnombreinfaces 0 eq {
      /FI2 [] def
      /FIC2 [] def
   } {
      /FI2 solid2 solidgetinfaces {{n add} apply} apply def
      /FIC2 solid2 solidgetincolors def
   } ifelse
   /FI [FI1 aload pop FI2 aload pop] def
   /FIC [FIC1 aload pop FIC2 aload pop] def

   %% les faces externes et leurs couleurs
   /FO1 solid1 solidgetoutfaces def
   /FOC1 solid1 solidgetoutcolors def
   /FO2 solid2 solidgetoutfaces {{n add} apply} apply def
   /FOC2 solid2 solidgetoutcolors def
   /FO [FO1 aload pop FO2 aload pop] def
   /FOC [FOC1 aload pop FOC2 aload pop] def

   /F [FO aload pop FI aload pop] def
   /FC [FOC aload pop FIC aload pop] def
   /IO [
      0 FO length 1 sub
      FI length 0 gt {
         dup 1 add dup FI length add 1 sub
      } {
         -1 -1
      } ifelse
   ] def

   S F generesolid
   dup FC solidputfcolors
   dup IO solidputinouttable
end
} def

%%%%% ### solidnormaleface ###
%% syntaxe : solid i solidnormaleface --> u, vecteur normale a la
%% face d indice i du solide
/solidnormaleface {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
%%    solid 0 i solidgetsommetface /G defpoint3d
%%    G
%%    solid 1 i solidgetsommetface
%%    vecteur3d
%%    G
%%    solid 2 i solidgetsommetface
%%    vecteur3d
%
   /n solid i solidfacenombresommets def
   n 3 ge {
      [
         solid 0 i solidgetsommetface
         solid 1 i solidgetsommetface
         solid 2 i solidgetsommetface
      ] isobarycentre3d /G defpoint3d
   } {
      solid i solidcentreface /G defpoint3d
   } ifelse
  %% debug %%   G 3dto2d point
   G
   solid 0 i solidgetsommetface
   /A defpoint3d
  %   gsave bleu A point3d grestore
   A
   vecteur3d normalize3d
   G
   solid 1 i solidgetsommetface
   /A defpoint3d
  %   gsave orange A point3d grestore
   A
   vecteur3d normalize3d
   vectprod3d
   /resultat defpoint3d
   resultat normalize3d
end
} def

%%%%% ### solidtransform ###
%% syntaxe : solid1 {f} solidtransform --> solid2, solid2 est le
%% transforme de solid1 par la transformation f : R^3 -> R^3
/solidtransform {
3 dict begin
   /@f exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidtransform) ==
      quit
   } if
   /les_sommets
      solid solidgetsommets {@f} papply3d
   def
   solid les_sommets solidputsommets
   solid
end
} def

%%%%% ### solidputcolor ###
%% syntaxe : solid i string solidputfcolor
/solidputfcolor {
3 dict begin
   /str exch def
   /i exch def
   /solid exch def
   /FC solid solidgetfcolors def
   i FC length lt {
      FC i str put
   } if
end
} def

%% syntaxe : solid solidgetincolors --> array
/solidgetincolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetincolors) ==
      quit
   } if
   solid solidwithinfaces {
      /fcol solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      fcol n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutcolors --> array
/solidgetoutcolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutcolors) ==
      quit
   } if
   /fcol solid solidgetfcolors def
   /IO solid solidgetinouttable def 
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   fcol n1 n getinterval 
end
} def
 
%% syntaxe : solid array solidputincolors --> -
/solidputincolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputincolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreinfaces ne {
      (Error : mauvaise longueur de tableau dans solidputincolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid str outputcolors
/outputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreoutfaces def
   solid [ n {color} repeat ] solidputoutcolors
end
} def

%% syntaxe : solid str inputcolors
/inputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreinfaces def
   solid [ n {color} repeat ] solidputincolors
end
} def

%% syntaxe : solid str1 str2 inoutputcolors
/inoutputcolors {
5 dict begin
   /colout exch def
   /colin exch def
   /solid exch def
   solid colin inputcolors
   solid colout outputcolors
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC length n n1 add lt {
         solid newcolorstable solidputfcolors
      } {
         FC n1 newcolorstable putinterval
      } ifelse
   } if
end
} def

/solidputcolors {
3 dict begin
   2 copy pop
   isstring {
      inoutputcolors
   } {
      outputcolors
   } ifelse
end
} def

%%%%% ### solidputhuecolors ###
%% syntaxe : solid table solidputhuecolors --> -
/solidputhuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 1 get
   s@lidputhuec@l@rs
end
} def

/solidputinhuecolors {
2 dict begin
   /table exch def
   /solid exch def
   solid solidgetinouttable /IO exch def
   solid solidwithinfaces {
      solid table
      IO 2 get
      IO 3 get
      s@lidputhuec@l@rs
   } if
end
} def

/solidputinouthuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 3 get IO 1 get max
   s@lidputhuec@l@rs
end
} def

%% syntaxe : solid table n1 n2 s@lidputhuec@l@rs --> -
%% affecte les couleurs des faces d indice n1 a n2 du solid solid, par
%% un degrade defini par la table.
 /s@lidputhuec@l@rs {
9 dict begin
   /n2 exch def
   /n1 exch def
   /table exch def
   /solid exch def
   /n n2 n1 sub def

   table length 2 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       a1 isstring {
          /lacouleurdepart {
             gsave
                [a0 cvx exec] length 0 eq {
                   a0 cvx exec currentrgbcolor
                } {
                   a0 cvx exec
                } ifelse 
             grestore
          } def
          /lacouleurarrivee {
             gsave
                [a1 cvx exec] length 0 eq {
                   a1 cvx exec currentrgbcolor
                } {
                   a1 cvx exec
                } ifelse 
             grestore
          } def
          /table [lacouleurdepart lacouleurarrivee] def
       } {
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {1} def
          /C {1} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
       } ifelse
   } if

   table length 4 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B table 2 get def
       /C table 3 get def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 6 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (setrgbcolor) def
   } if

   table length 7 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 8 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /d0 table 3 get def
       /a1 table 4 get def
       /b1 table 5 get def
       /c1 table 6 get def
       /d1 table 7 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {d0 i d1 d0 sub mul n 1 sub div add} def
       /espacedecouleurs (setcmykcolor) def
   } if

   n1 1 n2 {
      /i exch def
      solid i
      [A B C D] espacedecouleurs astr2str
      solidputfcolor
   } for
   
end
} def

%%%%% ### solidrmface ###
%% syntaxe : solid i solidrmface -> -
/solidrmface {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidrmface) ==
      quit
   } if
   %% on enleve la face
   /F solid solidgetfaces def
   F length 1 sub i lt {
      (Error : indice trop grand dans solidrmface) ==
      quit
   } if
   [
      0 1 F length 1 sub {
         /j exch def
         i j ne {
            F j get
         } if
      } for
   ]
   /NF exch def
   solid NF solidputfaces
   %% on enleve la couleur correspondante
   /FC solid solidgetfcolors def
   [
      0 1 FC length 1 sub {
         /j exch def
         i j ne {
            FC j get
         } if
      } for
   ]
   /NFC exch def
   solid NFC solidputfcolors
   %% on ajuste la table inout
   /IO solid solidgetinouttable def
   solid i solidisoutface {
      IO 1 IO 1 get 1 sub put 
      solid solidwithinfaces {
         IO 2 IO 2 get 1 sub put
         IO 3 IO 3 get 1 sub put
      } if
   } if
   solid i solidisinface {
      IO 1 IO 1 get 1 sub put
      IO 2 IO 2 get 1 sub put
      IO 3 IO 3 get 1 sub put
   } if
   solid IO solidputinouttable
end
} def

%% syntaxe : solid table solidrmfaces --> -
/solidrmfaces {
2 dict begin
   /table exch bubblesort reverse def
   /solid exch def
   table {solid exch solidrmface} apply
end
} def

%%%%% ### videsolid ###
%% syntaxe : solid videsolid -> -
/videsolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans videsolid) ==
      quit
   } if
   solid solidwithinfaces not {
      /IO solid solidgetinouttable def
      /FE solid solidgetfaces def
      /n FE length def
      IO 2 n put
      IO 3 2 n mul 1 sub put
      solid IO solidputinouttable
      %% on inverse chaque face
      /FI FE {reverse} apply def
      solid FE FI append solidputfaces
      %% et on rajoute autant de couleurs vides que de faces
      /FEC solid solidgetfcolors def
%      /FIC [FI length {()} repeat] def
%      solid FEC FIC append solidputfcolors
      solid FEC duparray append solidputfcolors
   } if 
end
} def

%%%%% ### solidnumfaces ###
%% syntaxe : solid array solidnumfaces
%% syntaxe : solid array bool solidnumfaces
%% array, le tableau des indices des faces a numeroter, est optionnel
%% si bool=true, on ne numerote que les faces visibles
/solidnumfaces {
5 dict begin
   dup isbool {
      /bool exch def
   } {
      /bool true def
   } ifelse
%   setTimes
   dup issolid not {
      %% on a un argument
      /option exch def 
   } if
   /sol exch def
   /n sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if

   0 1 option length 1 sub {
      /i exch def
      /j option i get def
      j (     ) cvs sol j bool cctextp3d
   } for
end
} def

%%%%% ### creusesolid ###
%% syntaxe : solid creusesolid -> -
/creusesolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans creusesolid) ==
      quit
   } if
   %% on enleve le fond et le chapeau
   solid 1 solidrmface
   solid 0 solidrmface
   %% on inverse chaque face
   solid videsolid
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 dessin des solides                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solidisinface ###
%% syntaxe : solid i solidisinface --> bool
%% true si i est l indice d une face interne, false sinon
/solidisinface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 2 get def
   /n2 IO 3 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### solidisoutface ###
%% syntaxe : solid i solidisoutface --> bool
%% true si i est l indice d une face externe, false sinon
/solidisoutface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 0 get def
   /n2 IO 1 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### planvisible ###
%% syntaxe : A k planvisible? --> true si le plan est visible
/planvisible? {
4 dict begin
   /normale_plan defpoint3d
   /origine defpoint3d
   /ligne_de_vue {
      origine
      GetCamPos
      vecteur3d
   } def
   ligne_de_vue normale_plan scalprod3d 0 gt
end
} def

%%%%% ### solidlight ###
/setlightintensity {
   /lightintensity exch def
} def

/setlightsrc {
   /lightsrc defpoint3d
} def

/setlight {
1 dict begin
gsave
   exec
   [ currentrgbcolor ] /lightcolor exch 
grestore
end
def
} def

%%%%% ### drawsolid ###
/solidlightOn {
   /s@lidlight true def
} def
/solidlightOff {
   /s@lidlight false def
} def
solidlightOff

%% syntaxe : solid i solidfacevisible? --> true si la face est visible
/solidfacevisible? {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   solid i solidgetface length 2 le {
      true
   } {
      /ligne_de_vue {
         solid i solidcentreface
         GetCamPos
         vecteur3d
      } def
   
      /normale_face {
         solid i solidnormaleface
      } def
      ligne_de_vue normale_face scalprod3d 0 gt
   } ifelse
end
} def

%% syntaxe : solid i affectecouleursolid_facei --> si la couleur de
%% la face i est definie, affecte fillstyle a cette couleur
/affectecouleursolid_facei {
3 dict begin
   /i exch def
   /solid exch def
   solid solidgetfcolors /FC exch def
   FC length 1 sub i ge {
      FC i get length 1 ge {
         /fillstyle FC i get ( Fill) append cvx
         solidgrid not {
            FC i get cvx exec
         } if
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
{def} if
} def

%% syntaxe : solid i dessinefacecachee
/dessinefacecachee {
11 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacecachee) ==
      quit
   } if

   /F solid solidgetfaces def
   /S solid solidgetsommets def

   %% face cachee => on prend chacune des aretes de la face et on
   %% la dessine
   4 dict begin
      /n F i get length def %% nb de sommets de la face
      0 1 n 1 sub {
         /k exch def
         /k1 F i k get_ij def              %% indice sommet1
         /k2 F i k 1 add n mod get_ij def  %% indice sommet2
         gsave
            currentlinewidth .5 mul setlinewidth
            pointilles
            [S k1 getp3d
            S k2 getp3d sortp3d] ligne3d
         grestore
      } for

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      /face_a_dessiner [  %% face visible : F [i]
         0 1 n 1 sub {
            /j exch def
            solid j i solidgetsommetface
         } for
      ] def 
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
	    solidintersectiontype 0 eq {
	       pointilles
	    } {
	       continu
	    } ifelse
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  table length 6 eq {
                     /lignedeniveau table store
                     exit
                  } {
                     /lignedeniveau [ 
                        lignedeniveau aload pop 
                        table 0 getp3d
                     ] store
                  } ifelse
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               [lignedeniveau aload pop sortp3d] ligne3d
            } if
         grestore
      } for         
   } if
   
   end
end
} def

%% syntaxe : solid i dessinefacevisible
/dessinefacevisible {
8 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacevisible) ==
      quit
   } if
   /F solid solidgetfaces def
   /S solid solidgetsommets def

   /n F i get length def %% nb de sommets de la face

   startest {
      s@lidlight {
         /coeff
            lightintensity
            solid i solidnormaleface normalize3d
            solid i solidcentreface lightsrc vecteur3d normalize3d
            scalprod3d mul
            0 max 1 min
         def
         /lightcolor where {
            pop
            /lacouleur lightcolor def
         } {
            /lacouleur [
               gsave
                  solid solidgetfcolors i get cvx exec currentrgbcolor
               grestore
            ] def
         } ifelse
         /fillstyle {
             lacouleur {coeff mul} apply setcolor Fill
         } def
         solidgrid not {
            lacouleur {coeff mul} apply setcolor
         } if
      } {
         n 2 eq {
            1 dict begin
               solidgridOff
               solid i affectecouleursolid_facei
            end
         } {
            solid i affectecouleursolid_facei
         } ifelse
      } ifelse
   } if

   /face_a_dessiner [  %% face visible : F [i]
      0 1 n 1 sub {
         /j exch def
         solid j i solidgetsommetface
      } for
   ] def 
   face_a_dessiner polygone3d

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  /lignedeniveau [ 
                     lignedeniveau aload pop 
                     table 0 getp3d
                     table length 4 ge {
                        table 1 getp3d
                     } if
                  ] store
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               solid i solidisinface solidintersectiontype 0 eq and {
                  pointilles 
               } if
               lignedeniveau ligne3d
            } if
         grestore
      } for         
   } if
      
end
} def

/drawsolid* {
1 dict begin
   /startest {true} def
   drawsolid
end
} def

/peintrealgorithme false def

/drawsolid** {
2 dict begin
   /aretescachees false def
   /peintrealgorithme true def
   drawsolid*
end
} def

%% syntaxe : solid array drawsolid
%% array est en option, il indique les faces triees
/drawsolid {
8 dict begin
   dup issolid not {
      /ordre exch def
   } if
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans drawsolid) ==
      quit
   } if
   solid nullsolid not {
      solid solidgetfaces
      /F exch def
      solid solidgetsommets
      /S exch def
      /n S length 3 idiv def

      currentdict /ordre known not {
         peintrealgorithme {
            %% tri des indices des faces par distance decroissante
            [
               0 1 F length 1 sub {
                  /i exch def
                  solid i solidcentreface
                  GetCamPos
                  distance3d
               } for
            ] doublequicksort pop reverse
         } {
            [
               0 1 F length 1 sub {
               } for
            ]
         } ifelse
         /ordre exch def
      } if

      0 1 F length 1 sub {
         /k exch def
         /i ordre k get def
         gsave
            solid i solidfacevisible? {
               solid i dessinefacevisible
            } if
         grestore
      } for
      aretescachees {
         0 1 F length 1 sub {
            /k exch def
            /i ordre k get def
            gsave
               solid i solidfacevisible? not {
                  solid i dessinefacecachee
               } if 
            grestore
         } for
      } if

%%       %% si on veut repasser les traits des faces visibles
%%       0 1 F length 1 sub {
%%          /k exch def
%%          /i ordre k get def
%%          gsave
%%          1 dict begin
%%             /startest false def
%%             solid i solidfacevisible? {
%%             solid i dessinefacevisible
%%             } if
%%          end
%%          grestore
%%       } for
   } if
end
} def

%%%%% ### segment_inter_planz ###
%% syntaxe : A B k segment_inter_planz --> array true ou false
/segment_inter_planz {
4 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A /zA exch def pop pop
   B /zB exch def pop pop
   zA k sub zB k sub mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            zA k eq {A} if
            zB k eq {B} if
         ] true
      } {
         %% intersection entre A et B
         [
            A B vecteur3d
            k zA sub zB zA sub div mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  plans affines                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### planaffine ###
%% plan : origine, base, range, ngrid
%% [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1. 1.] ]

/explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.] ] def

%% syntaxe : any isplan --> bool
/isplan {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 6 eq {
         candidat 3 get isarray {
            candidat 4 get isarray {
               candidat 5 get isarray              
            } {
               false
            } ifelse
         } {
            false
         } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/newplanaffine {
   [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1 1]] 
} def

/dupplan {
4 dict begin
   /leplan exch def
   /result newplanaffine def
   result leplan plangetorigine planputorigine
   result leplan plangetbase planputbase
   result leplan plangetrange planputrange
   result leplan plangetngrid planputngrid
   result
end
} def

%% syntaxe : plantype getorigine --> x y z
/plangetorigine {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetorigine) ==
      Error
   } if
   plan 0 get 
   plan 1 get 
   plan 2 get 
end
} def

%% syntaxe : plantype getbase --> [u v]
%% ou u, v et w vecteurs de R^3
/plangetbase {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetbase) ==
      Error
   } if
   plan 3 get 
end
} def

%% syntaxe : plantype getrange --> array
%% ou array = [xmin xmax ymin ymax]
/plangetrange {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetrange) ==
      Error
   } if
   plan 4 get 
end
} def

%% syntaxe : plantype getngrid --> array
%% ou array = [n1 n2]
/plangetngrid {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetngrid) ==
      Error
   } if
   plan 5 get 
end
} def

%% ===================

%% syntaxe : plantype x y z putorigine --> -
/planputorigine {
4 dict begin
   /z exch def
   /y exch def
   /x exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputorigine) ==
      Error
   } if
   plan 0 x put 
   plan 1 y put 
   plan 2 z put 
end
} def

%% syntaxe : plantype [u v w] putbase --> -
%% ou u, v et w vecteurs de R^3
/planputbase {
2 dict begin
   /base exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputbase) ==
      Error
   } if
   plan 3 base put 
end
} def

%% syntaxe : plantype array putrange --> -
%% ou array = [xmin xmax ymin ymax]
/planputrange {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputrange) ==
      Error
   } if
   plan 4 table put 
end
} def

%% syntaxe : plantype array putngrid --> -
%% ou array = [n1 n2]
/planputngrid {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputngrid) ==
      quit
   } if
   plan 5 table put 
end
} def

%% -3 3 -2 2 1. 1. newgrille
%% drawsolid

%orange

%% plan : origine, base, range, ngrid

%% syntaxe : plantype drawplanaffine --> -
/drawplanaffine {
5 dict begin
   /plan exch def
   plan plangetbase 
   aload pop
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   newpath
      plan plangetrange plan plangetngrid aload pop  quadrillagexOy_
      plan plangetorigine [imI imK] false planprojpath
   Stroke
end
} def


%% %% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% %% plan defini par l equation ax+by+cz+d=0, 
%% %% rotation de alpha autour de la normale (alpha est optionnel)
%% %% origine (x0, y0, z0). l origine est optionnelle
%% /defeqplanaffine {
%% 5 dict begin
%%    dup isarray {
%%       /alpha 0 def
%%    } {
%%       dup isstring {
%%          /alpha 0 def
%%       } {
%%          /alpha exch def
%%       } ifelse
%%    } ifelse
%%    dup isstring {
%%       cvx /origine exch def
%%    } if
%%    /table exch def
%%    table length 4 ne {
%%       (Erreur : mauvais type d argument dans defeqplanaffine) ==
%%       Error
%%    } if
%%    table 0 get /a exch def
%%    table 1 get /b exch def
%%    table 2 get /c exch def
%%    table 3 get /d exch def
%%    /resultat newplanaffine def
%%    [a b c alpha] normalvect_to_orthobase
%%    /imK defpoint3d
%%    /imJ defpoint3d
%%    /imI defpoint3d
%%    resultat [imI imJ imK] planputbase
%%    currentdict /origine known {
%%       origine /z exch def /y exch def /x exch def
%%       a x mul b y mul add c z mul add d add 0 ne {
%%          (Erreur : mauvaise origine dans defeqplanaffine) ==
%%          Error
%%       } if
%%       resultat origine planputorigine
%%    } {
%%       c 0 ne {
%%          resultat 0 0 d neg c div planputorigine
%%       } {
%%          a 0 ne {
%%             resultat d neg a div 0 0 planputorigine
%%          } {
%%             resultat 0 d neg b div 0 planputorigine
%%          } ifelse
%%       } ifelse
%%    } ifelse
%%    resultat
%% end
%% } def

%% /explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 1] ] def
%% explan drawplanaffine
%% noir
%% /explan [0 0 2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 .5] ] def
%% explan drawplanaffine

%% orange
%% [0 0 1 -2] defeqplanaffine
%% drawplanaffine
%% noir
%% [0 0 1 0] defeqplanaffine
%% drawplanaffine
%% bleu
%% [1 1 1 0] (1 -1 0) defeqplanaffine
%% drawplanaffine
%% 

/dessinebase {
4 dict begin
gsave
   /V3 defpoint3d
   /V2 defpoint3d
   /V1 defpoint3d
   /M0 defpoint3d
   rouge
   V3 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   bleu
   V2 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   orange
   V1 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
grestore
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def


%% syntaxe : plantype newplan --> solid
/newplan {
5 dict begin
   /lepl@n exch def
   lepl@n plangetbase /@base exch def
   @base 0 getp3d /@U defpoint3d
   @base 1 getp3d /@V defpoint3d
   lepl@n plangetorigine /@M defpoint3d
   lepl@n plangetrange /@range exch def
   lepl@n plangetngrid /@ngrid exch def
   /@F {
   2 dict begin
      /@y exch def
      /@x exch def
      @U @x mulv3d
      @V @y mulv3d
      addv3d
      @M addv3d
   end
   } def
   @range aload pop @ngrid {@F} newsurfaceparametree
end
} def

%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /eqplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a eqplan 0 get def
   /@b eqplan 1 get def
   /@c eqplan 2 get def
   /@d eqplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add
end
} def

/plan2eq {
6 dict begin
   /leplan exch def
   leplan plangetbase aload pop vectprod3d
   /c exch def
   /b exch def
   /a exch def
   leplan plangetorigine
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg]
end
} def

%% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% plan defini par l equation ax+by+cz+d=0, 
%% rotation de alpha autour de la normale (alpha est optionnel)
%% origine (x0, y0, z0). l origine est optionnelle
/eq2plan {
5 dict begin
   dup isarray {
      /alpha 0 def
   } {
      dup isstring {
         /alpha 0 def
      } {
         /alpha exch def
      } ifelse
   } ifelse
   dup isstring {
      cvx /origine exch def
   } if
   /table exch def
   table length 4 ne {
      (Erreur : mauvais type d argument dans eq2plan) ==
      quit
   } if
   table 0 get /a exch def
   table 1 get /b exch def
   table 2 get /c exch def
   table 3 get /d exch def
   /resultat newplanaffine def
   [a b c alpha] normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   resultat [imI imJ] planputbase
   currentdict /origine known {
      origine /z exch def /y exch def /x exch def
      a x mul b y mul add c z mul add d add 0 ne {
         (Erreur : mauvaise origine dans eq2plan) ==
         quit
      } if
      resultat origine planputorigine
   } {
      c 0 ne {
         resultat 0 0 d neg c div planputorigine
      } {
         a 0 ne {
            resultat d neg a div 0 0 planputorigine
         } {
            b 0 ne {
               resultat 0 d neg b div 0 planputorigine
            } {
               (Error dans eq2plan : (a,b,c) = (0,0,0)) ==
            } ifelse
         } ifelse
      } ifelse
   } ifelse
   resultat
end
} def

/points2eqplan {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   A C vecteur3d
   vectprod3d
   normalize3d
   /c exch def
   /b exch def
   /a exch def
   A
   /zA exch def
   /yA exch def
   /xA exch def
   [a b c a xA mul b yA mul add c zA mul add neg]
end
} def

%% /monplan 
%% %[0 0 -2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.]]
%% [0 0 1 1] 30 eq2plan
%% def
%% 
%% [0 0 1 -2] eq2plan newplan
%% dup (blanc) outputcolors
%% monplan newplan
%% dup (blanc) outputcolors
%% solidfuz
%% drawsolid**
%% monplan plangetorigine
%% monplan plangetbase aload pop dessinebase

%% syntaxe : x0 y0 z0 [normalvect] norm2plan
/norm2plan {
9 dict begin
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   imK
   /c exch def
   /b exch def
   /a exch def
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg] eq2plan
   dup x0 y0 z0 planputorigine
   dup [imI imJ] planputbase
end
} def

%% syntaxe : plantype planxmarks
/planxmarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      xmin truncate cvi 0 smoveto
      xmax truncate cvi 0 slineto
      leplan mybool projpath
   Stroke
   xmin truncate cvi xmkstep xmax truncate cvi {
      dup 0 ne {
         /x exch def
         x
         x x truncate eq {
            cvi
         } if
         dup chaine cvs exch 0 leplan mybool dctextp3d
         newpath
            x 0 smoveto
            0 2.5 rmoveto
            0 -5 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planymarks
/planymarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      0 ymin truncate cvi smoveto
      0 ymax truncate cvi slineto
      leplan mybool projpath
   Stroke
   ymin truncate cvi ymkstep ymax truncate cvi {
      dup 0 ne {
         /y exch def
         y
         y y truncate eq {
             cvi
         } if
         dup chaine cvs exch 0 exch leplan mybool cltextp3d
         newpath
            0 y smoveto
            2.5 0 rmoveto
            -5 0 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planmarks
/planmarks {
1 dict begin
    dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup mybool planxmarks mybool planymarks
end
} def

%% bleu
%% [-3 3 -2 2] quadrillagexOy_
%% Stroke
%% noir

%% syntaxe : [xmin xmax ymin ymax] dx dy quadrillagexOy_
/quadrillagexOy_ {
4 dict begin
   dup isarray {
      /dx 1 def
      /dy 1 def
   } {
      /dy exch def
      dup isarray {
         /dx dy def
      } {
         /dx exch def
      } ifelse
   } ifelse
   /table exch def
   table 0 get /xmin exch def
   table 1 get /xmax exch def
   table 2 get /ymin exch def
   table 3 get /ymax exch def
   ymin dy ymax {
      /y exch def
      xmin y smoveto
      xmax y slineto
   } for
   xmin dx xmax {
      /x exch def
      x ymin smoveto
      x ymax slineto
   } for
end
} def

%% syntaxe : plan [ngrid] planquadrillage
/planquadrillage {
4 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /ngrid [1 1] def
   } {
      /ngrid exch def
   } ifelse
   /leplan exch def
   /dx ngrid 0 get def
   /dy ngrid 1 get def
   /table leplan plangetrange def
   table 0 get cvi truncate /xmin exch def
   table 1 get cvi truncate /xmax exch def
   table 2 get cvi truncate /ymin exch def
   table 3 get cvi truncate /ymax exch def
   newpath
      ymin dy ymax {
         /y exch def
         xmin y smoveto
         xmax y slineto
      } for
      xmin dx xmax {
         /x exch def
         x ymin smoveto
         x ymax slineto
      } for
      leplan mybool projpath
   Stroke
end
} def

%% syntaxe : plantype str1 str2 planshowbase -> - 
%% syntaxe : plantype str2 planshowbase -> - 
%% syntaxe : plantype planshowbase -> - 
/planshowbase {
3 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isstring {
      /couleur2 exch def
      dup isstring {
         /couleur1 exch def
      } {
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
   } ifelse
   mybool bprojscene
      couleur1 cvx exec
      newpath
         0 0 smoveto
         1 0 slineto
      Stroke
      0 0 1 0 oldarrow
      couleur2 cvx exec
      newpath
         0 0 smoveto
         0 1 slineto
      Stroke
      0 0 0 1 oldarrow
   eprojscene
end
} def

%% syntaxe : plantype str1 str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str3 planshowbase3d -> - 
%% syntaxe : plantype planshowbase3d -> - 
%% syntaxe : plantype str1 str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str3 array planshowbase3d -> - 
%% syntaxe : plantype array planshowbase3d -> - 
/planshowbase3d {
7 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup dup isarray exch isplan not and {
      /table exch def
   } {
      /table {} def
   } ifelse
   dup isstring {
      /couleur3 exch def
      dup isstring {
         /couleur2 exch def
         dup isstring {
            /couleur1 exch def
         } {
            /couleur1 (rouge) def
         } ifelse
      } {
         /couleur2 (vert) def
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
      /couleur3 (bleu) def
   } ifelse
   /plan exch def
   plan couleur1 couleur2 mybool planshowbase
   plan plangetorigine /I defpoint3d
   plan plangetbase
   dup 0 getp3d /u defpoint3d
   1 getp3d /v defpoint3d
   u v vectprod3d table newvecteur
   {I addv3d} solidtransform
   dup couleur3 solidputcolors
   solidgridOff
   drawsolid**
end
} def

%% syntaxe : plantype x y z plantranslate --> -
/plantranslate {
4 dict begin
   /M defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plantranslate) ==
      quit
   } if
   plan plan plangetorigine M addv3d planputorigine
end
} def

% syntaxe : alpha_x alpha_y alpha_z rotateOpplan --> -
/rotateOplan {
4 dict begin
   /Rxyz defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans rotateOplan) ==
      quit
   } if
   plan plan plangetorigine Rxyz rotateOpoint3d planputorigine

   plan plangetbase 0 getp3d /U defpoint3d
   plan plangetbase 1 getp3d /V defpoint3d
   plan [
      U Rxyz rotateOpoint3d
      V Rxyz rotateOpoint3d
   ] planputbase
end
} def

%% syntaxe : plantype phi rotateplan --> -
/rotateplan {
5 dict begin
   /phi exch def
   /leplan exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U phi cos mulv3d
   V phi sin mulv3d addv3d /U0 defpoint3d
   U phi sin neg mulv3d
   V phi cos mulv3d addv3d /V0 defpoint3d
   leplan [U0 V0] planputbase
end
} def

%% syntaxe : solid i solidface2plan --> plantype
%% syntaxe : solid i I solidface2plan --> plantype
/solidface2plan {
5 dict begin
   2 copy pop issolid {
      /i exch def
      /solid exch def
      solid i solidcentreface /I defpoint3d
   } {
      /I defpoint3d
      /i exch def
      /solid exch def
   } ifelse
   /result newplanaffine def
   solid i solidcentreface /G defpoint3d
   solid i solidnormaleface /K defpoint3d
   solid 0 i solidgetsommetface
   solid 1 i solidgetsommetface
   milieu3d /A defpoint3d
   G A vecteur3d normalize3d /U defpoint3d
   K U vectprod3d /V defpoint3d
   result [U V] planputbase
   result I planputorigine
   result
end
} def

%%%%% ### fin insertion ###
%% syntaxe : x y plantype pointplan --> X Y Z
/pointplan {
5 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U x mulv3d V y mulv3d addv3d
end
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     operations sur des solides particuliers        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/piedist {
4 dict begin
   /mypie exch def
   mypie 0 solidgetface length /n exch def
   mypie n 2 idiv solidgetsommet /A defpoint3d
   mypie n 2 idiv 1 add solidgetsommet /B defpoint3d
   A B milieu3d GetCamPos distance3d
end
} def

/sortpieset {
5 dict begin
   dup issolid {
      ]
   } if
   /table exch def
   [
      0 1 table length 1 sub {
         /i exch def
         table i get piedist
      } for
   ]
   doublequicksort pop reverse
   /result exch def
   [
      0 1 result length 1 sub {
         /i exch def
         table result i get get 
      } for
   ]
end
} def

/drawpieset {
1 dict begin
   /startest true def
   sortpieset dup {drawsolid**} apply {0 dessinefacevisible} apply
end
} def

%%%%% ### solidchanfreine ###
%% syntaxe : solid coeff solidchanfreine --> solid
/solidchanfreine {
10 dict begin
   /coeff exch def
   /solid exch def
   /result newsolid def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidchanfreine) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def

   %% ajout des faces reduites
   0 1 nf 1 sub {
      /i exch def
      /Fsommets solid i solidgetsommetsface def
      /Findex solid i solidgetface def
      /ns Fsommets length 3 idiv def
      /couleurfaceorigine solid i solidgetfcolor def
      Fsommets isobarycentre3d /G defpoint3d
      %% on ajoute les nouveaux sommets
      /Sindex [] def
      0 1 ns 1 sub {
         /j exch def
         /Sindex [ Sindex aload pop
            Fsommets j getp3d /M defpoint3d
            result M G coeff hompoint3d solidaddsommet
         ] store
      } for
      %% Sindex contient les indices des nouveaux sommets
      result Sindex couleurfaceorigine solidaddface
   } for

   %% ajout des faces rectangulaires entre faces d'origines adjacentes
   %% pour chaque face de depart
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      /Fres result i solidgetface def
      %% pour chaque arete de la face
      0 1 F length 1 sub {
         /j exch def
         /trouve false def
         /indice1 F j get def
         /indice2 F j 1 add F length mod get def
         /a1 j def
         /a2 j 1  add F length mod def
         %% on regarde toutes les autres faces
         i 1 add 1 nf 1 sub {
            /k exch def
            /Ftest solid k solidgetface def
            indice1 Ftest in {pop true} {false} ifelse
            indice2 Ftest in {pop true} {false} ifelse
            and {
               /indiceFadj k def
               indice1 Ftest in pop /k1 exch def
               indice2 Ftest in pop /k2 exch def
               /trouve true def
            exit
            } if
         } for
         trouve {
            /Fadj solid indiceFadj solidgetface def
            result [
               Fres a1 get
               result indiceFadj solidgetface k1 get
               result indiceFadj solidgetface k2 get
               Fres a2 get
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   %% pour chaque face
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      %% et pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /k F j get def
         solid k solidfacesadjsommet /adj exch def
         %% adj est le tableau des indices des faces adjacentes
         %% au sommet d'indice k
         %% rque : toutes les faces d'indice strict inferieur a i
         %% sont deja traitees
         %% Pour chaque face adjacente, on repere l'indice du sommet concerne dans
         %% la face
         adj min i lt not {
            /indadj [] def
            0 1 adj length 1 sub {
               /m exch def
               k solid adj m get solidgetface in {
                  /ok exch def
                  /indadj [indadj aload pop ok] store
               } if
            } for
         
            /aajouter [
               0 1 adj length 1 sub {
                  /m exch def
                  result adj m get solidgetface indadj m get get
               } for
            ] def

            %% la table des sommets
            [0 1 aajouter length 1 sub {
               /m exch def
               result aajouter m get solidgetsommet
            } for]
            solid k solidgetsommet %% le point indiquant la direction de la normale
            ordonnepoints3d
            /indicestries exch def

            result [
               0 1 indicestries length 1 sub {
                  /m exch def
                  aajouter indicestries m get get
               } for
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   result
end
} def

%%%%% ### solidplansection ###
%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /@qplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a @qplan 0 get def
   /@b @qplan 1 get def
   /@c @qplan 2 get def
   /@d @qplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add 
end
} def

%% syntaxe : A B eqplan segment_inter_plan --> array true ou false
%% array contient 1 point M si [AB] inter plan = {M}
%% array contient les 2 points A et B si [AB] inter plan = [AB]
/segment_inter_plan {
4 dict begin
   dup isplan {plan2eq} if
   /plan exch def
   plan aload pop
   /d exch def
   /c exch def
   /b exch def
   /a exch def
   /B defpoint3d
   /A defpoint3d
   A 
   /zA exch def
   /yA exch def
   /xA exch def
   B 
   /zB exch def
   /yB exch def
   /xB exch def
   /imA a xA mul b yA mul add c zA mul add d add def
   /imB a xB mul b yB mul add c zB mul add d add def
   imA imB mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            imA 0 eq {A} if 
            imB 0 eq {B} if 
         ] true
      } {
         %% intersection entre A et B
         /k 
            imA neg
            xB xA sub a mul
            yB yA sub b mul add
            zB zA sub c mul add
            dup 0 eq {
               (Error dans segment_inter_plan) ==
               quit
            } if
            div
         def
         [
            A B vecteur3d
            k mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def

%% syntaxe : array1 arrayrmdouble --> array2
%% remplace 2 elts identiques consecutifs par 1 elt
/arrayrmdouble {
5 dict begin
   /table exch def
   /result [table 0 get] def
   /j 0 def
   1 1 table length 1 sub {
      /i exch def
      table i get
      result j get
      eq not {
         /result [result aload pop table i get] store
         /j j 1 add store
      } if
   } for
   result
end
} def

%% syntaxe : solid eqplan/plantype solidplansection --> solid2
/solidplansection {
10 dict begin
   dup isbool {
      /tr@nsmit exch def
   } {
      /tr@nsmit false def
   } ifelse
   dup isplan {
      plan2eqplan
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   dupsolid /result exch def
   /solid exch def
   /aenlever [] def
   /indnouveauxsommets [] def
   /nouvellesaretes [] def

   %% pour chaque face d'indice i
   0 1 solid solidnombrefaces 1 sub {
      /i exch def
      /lacouleur solid i solidgetfcolor def
      /F solid i solidgetface def %% table des indices des sommets
      /n F length def %% nb d'aretes
      /k1 -1 def
      /k2 -1 def
      /k3 -1 def
      /k4 -1 def
      /k3a -3 def
      /k4a -3 def
      %% pour chaque arete [AB]
      0 1 n 1 sub {
         /j exch def
         %% arete testee : [j, j+1 mod n] (indices relatifs a la face i)
         solid j i solidgetsommetface /A defpoint3d
         solid j 1 add n mod i solidgetsommetface /B defpoint3d
         %% y a-t-il intersection
         A B eqplan segment_inter_plan {
            %% il y a intersection
            dup length 6 eq {
               %% l'intersection, c'est [AB]
               /k1 -1 def
               /k2 -1 def
               /k3 -1 def
               /k4 -1 def
               /k3a -1 def
               /k4a -1 def
               dup 0 getp3d /A defpoint3d
               1 getp3d /B defpoint3d
               result A solidaddsommet /a1 exch def
               result B solidaddsommet /a2 exch def
               /indnouveauxsommets [
                  indnouveauxsommets aload pop a1 a2
               ] store
               /nouvellesaretes [
                  [a1 a2]
                  nouvellesaretes aload pop
               ] store
               exit %% c est deja scinde
            } if
            %% il y a intersection <> [AB]
            k1 0 lt {
            %% 1ere intersection de la face
               /k1 j def %% sommet precedent intersection 1
               result exch aload pop solidaddsommet
               /k1a exch def %% sommet intersection 1
            } {
               k2 0 lt {
               %% 2eme intersection de la face
                  /k2 j def %% sommet precedent intersection 2
                  result exch aload pop solidaddsommet
                  /k2a exch def %% sommet intersection 2
               } {
                  k3 0 lt {
                  %% 3eme intersection de la face
                     /k3 j def %% sommet precedent intersection 3
                     result exch aload pop solidaddsommet
                     /k3a exch def %% sommet intersection 3
                  } {
                  %% 4eme intersection de la face
                     /k4 j def %% sommet precedent intersection 4
                     result exch aload pop solidaddsommet
                     /k4a exch def %% sommet intersection 4
                  } ifelse
               } ifelse
            } ifelse
         } if
      } for
      
      %% y a-t-il eu une coupe ?
      %% si oui, il faut scinder la face d'indice i en cours 
      k1 0 ge {
%% (coupe) ==
%% (n) == n ==
%% k1 == k2 == k3 == k4 ==
%% (a) ==
%% k1a == k2a == k3a == k4a ==
         k1a k2a eq k3 0 lt and {
            %% 1 pt d'intersection
         } {
            %% il y a coupe, on cherche a eliminer les
            %% doublons dans {k1a, k2a, k3a, k4a}
            k1a k2a eq k3 0 ge and {
               %% 2 pts d'intersection
               /k2a k3a def
               /k2 k3 def
            } if
            k1a k3a eq k4 0 ge and {
               %% 2 pts d'intersection
               /k2a k4a def
               /k2 k4 def
            } if
            /nouvellesaretes [
               [k1a k2a]
               nouvellesaretes aload pop
            ] store
            [
               k1a F k1 1 add n mod get ne {
                  k1a
               } if
               k1 1 add n mod 1 k2 {F exch get} for
               k2a F k2 get ne {
                  k2a
               } if
            ]
            result exch lacouleur solidaddface
            /indnouveauxsommets [indnouveauxsommets aload pop k1a k2a] store
            [
               k2a F k2 1 add n mod get ne {
                  k2a
               } if
               k2 1 add n ne {
                  k2 1 add n mod 1 n 1 sub {F exch get} for
               } if
               0 1 k1 {F exch get} for
               k1a F k1 get ne {
                  k1a
               } if
            ]
            result exch lacouleur solidaddface
            /aenlever [aenlever aload pop i] store
         } ifelse
      } if
   } for
   result aenlever solidrmfaces

   nouvellesaretes separe_composantes
   /composantes exch def

   %% pour chacune des composantes
   0 1 composantes length 1 sub {
      %% on oriente et on ajoute la face
      /icomp exch def
      %indnouveauxsommets bubblesort arrayrmdouble
      /indnouveauxsommets composantes icomp get def
      %% maintenant, on ajoute la face de plan de coupe
      /nouveauxsommets [
         0 1 indnouveauxsommets length 1 sub {
            /i exch def
            result indnouveauxsommets i get solidgetsommet
         } for
      ] def
   
      0 0 0 eqplan pointeqplan 0 eq {
         /ptref {0 1 1} def
      } {
         /ptref {0 0 0} def
      } ifelse
   
      %% restera a traiter le cas limite ou la nouvelle face existe deja
      %% tester si max(indicestries) < nb sommets avant section
      nouveauxsommets ptref ordonnepoints3d
      /indicestries exch def
      /nvelleface [
         0 1 indicestries length 1 sub {
            /m exch def
            indnouveauxsommets indicestries m get get
         } for
      ] def
      /F result solidgetfaces def
      /FC result solidgetfcolors def
      /IO result solidgetinouttable def
      /n1 IO 1 get def
      IO 1 n1 1 add put
      result IO solidputinouttable
      result [nvelleface F aload pop] solidputfaces
      result [lacouleur FC aload pop] solidputfcolors
   } for
   result
   tr@nsmit {
      composantes length 
   } if
end    
} def

%% syntaxe : elt array compteoccurences
%% ou array est un tableau du type [ [a1 a2] [b1 b2] [c1 c2] ... ]
/compteoccurences {
5 dict begin
   /table exch def
   /elt exch def
   /n 0 def
   0 1 table length 1 sub {
      /i exch def
      elt table i get in {
         pop
         /n n 1 add store
      } if
   } for
   n
end
} def

/separe_composantes {
10 dict begin
   /result [] def %% les composantes deja faites
   /table exch def %% ce qui reste a faire

%   (recu) == table {==} apply
   {
      /ext1 table 0 get 1 get def
      /ext0 table 0 get 0 get def
      /composante [] def
   
      { %% maintenant on suit les extremites et on epluche une composante
         /change false def
         /aenlever [] def
         0 1 table length 1 sub {
            /i exch def
            ext1 table i get In
            ext0 table i get In or {
               /aenlever [aenlever aload pop i] store
               /change true store
               %% l'arete i contient l'extremite ext0 ou ext1
               ext0 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext0 exch store
                  ext0 composante In not {
                     /composante [composante aload pop ext0] store
                  } if
                  %% on verifie que ext0 est legitime
                  ext0 table compteoccurences 2 gt {
                     /ext0 -1 store
                  } if
               } if
               ext1 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext1 exch store
                  ext1 composante In not {
                     /composante [composante aload pop ext1] store
                  } if
                  %% on verifie que ext1 est legitime
                  ext1 table compteoccurences 2 gt {
                     /ext1 -1 store
                  } if
               } if
            } if
         } for
         %% il faut reconstruire table
         /table [
            0 1 table length 1 sub {
               /i exch def
               i aenlever in {
                  pop
               } {
                  table i get
               } ifelse
            } for
         ] store
         change not {exit} if
      } loop
      %% on vient de finir une composante
      /result [result aload pop composante] store
      %% (nouvelle comp) == composante {==} apply
      table length 0 eq {exit} if
   } loop
   result
%   (renvoie) == result {==} apply
end
} def

/solideqplansepare {solidplansepare} def
    
%% syntaxe : solid eqplan/plantype solidplansepare --> solid1 solid2
/solidplansepare {
10 dict begin
   dup isplan {
      plan2eq
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   eqplan true solidplansection
   /nbcomposantes exch def
   /solid exch def
   /n solid solidnombrefaces def

   /F [] def
   /FC [] def
   %% on retire les faces de coupe
   0 1 nbcomposantes 1 sub {
      /i exch def
      /F [F aload pop solid i solidgetface] store
      /FC [FC aload pop solid i solidgetfcolor] store
   } for
   solid [0 1 nbcomposantes 1 sub {} for] solidrmfaces
   /n n nbcomposantes sub store

   %% on separe les autres faces en 2 parties
   /lesneg [] def %% indices des faces "positives"
   /lespos [] def %% indices des faces negatives"
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /G defpoint3d
      G eqplan pointeqplan dup 0 gt {
         pop
         /lespos [lespos aload pop i] store
      } {
         0 lt {
            /lesneg [lesneg aload pop i] store
         } {
%           /lesneg [lesneg aload pop i] store
%           /lespos [lespos aload pop i] store
         } ifelse
      } ifelse
   } for
   solid
   dupsolid dup lesneg solidrmfaces
   /result1 exch def
   dupsolid dup lespos solidrmfaces
   /result2 exch def
   pop

   0 1 nbcomposantes 1 sub {
      /i exch def
      /facecoupe F i get def
      /couleurfacecoupe FC i get def
      /lesfaces1 result1 solidgetfaces def
      /lescouleurs1 result1 solidgetfcolors def
      /IO1 result1 solidgetinouttable def
      /lesfaces2 result2 solidgetfaces def
      /lescouleurs2 result2 solidgetfcolors def
      /IO2 result2 solidgetinouttable def
      %% on rajoute maintenant la face du plan de coupe
%      result1 facecoupe couleurfacecoupe solidaddface
      result1 [facecoupe lesfaces1 aload pop] solidputfaces
      result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
      result1 IO1 dup dup 1 get 1 add 1 exch put solidputinouttable
      %% et on verifie l'orientation
%      result1 dup solidnombrefaces 1 sub solidnormaleface 
%      result1 dup solidnombrefaces 1 sub solidcentreface addv3d
      result1 0 solidnormaleface 
      result1 0 solidcentreface addv3d
      eqplan pointeqplan 0 gt {
         %% l'orientation est mauvaise
         result1 0 solidrmface 
         result2 [facecoupe lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result1 [facecoupe reverse lesfaces1 aload pop] solidputfaces
         result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
         result1 dup solidgetinouttable dup dup 1 get 1 add 1 exch put solidputinouttable
      } {
         %% l'orientation est ok
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result2 [facecoupe reverse lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
      } ifelse
   } for
   
   %% maintenant on enleve les sommets isoles
   /sommetspos [] def
   /sommetsneg [] def
   %% pour chaque face du cote negatif
   0 1 lesneg length 1 sub {
      lesneg exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetsneg in not {
            %% et s'il est isole, on peut l'enlever
            result1 sommet solidsommetsadjsommet length 0 eq {
               /sommetsneg [sommetsneg aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetsneg bubblesort reverse {result1 exch solidrmsommet} apply

   %% pour chaque face du cote positif
   0 1 lespos length 1 sub {
      lespos exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetspos in not {
            %% et s'il est isole, on peut l'enlever
            result2 sommet solidsommetsadjsommet length 0 eq {
               /sommetspos [sommetspos aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetspos bubblesort reverse {result2 exch solidrmsommet} apply

   result1 result2
end
} def

%%%%% ### solidaffine ###
%% syntaxe : solid coeff i solidaffine -> -
%% syntaxe : solid coeff array solidaffine -> -
%% syntaxe : solid coeff solidaffine -> -
%% syntaxe : solid coeff str solidaffine -> -
%% syntaxe : solid coeff bool solidaffine -> -
/solidaffine {
10 dict begin
   dup isbool {
      /rmfacecentrale exch def
   } {
      /rmfacecentrale true def
   } ifelse
   dup isstring {
      /couleurface exch def
   } if
   2 copy pop issolid {
      %% 2 arguments --> on affine tout
      2 copy pop solidnombrefaces /n exch def
      /table [n 1 sub -1 0 {} for] def 
   } {
      %% 1 tableau --> il donne les faces a enlever
      dup isarray {
         /table exch bubblesort reverse def
      } {
      %% 1 seule face a enlever
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /coeff exch def
   /solid exch def
   0 1 table length 1 sub {
      /i exch def
      solid coeff table i get 
      currentdict /couleurface known {
         couleurface 
      } if
      rmfacecentrale s@lidaffineface
   } for
end
} def

%% syntaxe : solid coeff i s@lidaffineface
 /s@lidaffineface {
10 dict begin
   /rmfacecentrale exch def
   dup isstring {
      /couleurface exch def
   } if
   /indice_a_chamfreiner exch def
   /i indice_a_chamfreiner def
   /coeff exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans affine) ==
      quit
   } if
   /n solid solidnombresommets def
   /F solid i solidgetsommetsface def
   /Findex solid i solidgetface def
   /ni F length 3 idiv def
   /couleurfaceorigine solid i solidgetfcolor def
   F isobarycentre3d /G defpoint3d
   %% on ajoute les nouveaux sommets
   /Sindex [] def
   0 1 ni 1 sub {
      /j exch def
      /Sindex [ Sindex aload pop
         solid G F j getp3d vecteur3d coeff mulv3d G addv3d solidaddsommet
      ] store
   } for
   %% Sindex contient les indices des nouveaux sommets
   %% on prepare les faces a ajouter
   /facestoadd [] def
   /facestoadd [facestoadd aload pop
   0 1 ni 1 sub {
      /j exch def
      [Findex j get
      Findex j 1 add ni mod get
      Sindex j 1 add ni mod get
      Sindex j get]
   } for
   ] store
   0 1 ni 1 sub {
      /i exch def
      solid facestoadd i get solidaddface
   } for
   %% on enleve la face d origine
   solid indice_a_chamfreiner solidrmface
   %% on ajuste les couleurs des nouvelles faces
   /N solid solidnombrefaces def
   0 1 ni 1 sub {
      /i exch def
      solid N 1 sub i sub couleurfaceorigine solidputfcolor
   } for
   %% puis on ajoute eventuellement la face centrale
   rmfacecentrale not {
      solid
      [0 1 ni 1 sub {
         /j exch def
         Sindex j get
      } for]
      solidaddface
      %% en ajustant la couleur de cette derniere
      solid N
      currentdict /couleurface known {
            couleurface 
      } {
         couleurfaceorigine
      } ifelse
      solidputfcolor
   } if
end
} def

%%%%% ### solidtronque ###
%% syntaxe : solid indicesommet k solidtronque --> solid
%% syntaxe : solid array k solidtronque --> solid
%% syntaxe : solid k solidtronque --> solid
%% k entier > 0, array = tableau des indices des sommets
/solidtronque {
10 dict begin
   /coeff exch def
   dup issolid {
      dup solidnombresommets /N exch def
      /table [0 1 N 1 sub {} for] def
   } {
      dup isarray {
         /table exch def
      } {
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   0 1 table length 1 sub {
      table exch get /no exch def
      result no solidgetsommet /sommetvise defpoint3d
      %% on recup les sommets adjacents au sommet vise
      /sommetsadj solid no solidsommetsadjsommet def
      %% on calcule les nouveaux sommets
      /nouveauxsommets [
         0 1 sommetsadj length 1 sub {
            /i exch def
            solid sommetsadj i get solidgetsommet
         } for
      ] {sommetvise exchp3d coeff ABpoint3d} papply3d def 
      %% on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G result no solidgetsommet vecteur3d /vecteurnormal defpoint3d
      %% on construit le tableau des angles ordonnes par rapport
      %% a la normale
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      %% on rajoute les sommets au solide, et on note les nouveaux indices
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% on ajoute la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      result no solidfacesadjsommet /lesfaces exch def
      %% on examine la face d indice i, et on elimine le
      %% sommet vise
      0 1 lesfaces length 1 sub {
         /i exch def
         /j lesfaces i get def
         /F result j solidgetface def 
         result [
            0 1 F length 1 sub {
               /k exch def 
               F k get dup no eq {pop} if
            } for
         ] j exch solidputface 
      } for
   } for
   table bubblesort reverse {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### dualpolyedre ###
%% syntaxe : solid dualpolyedreregulier --> solid
%% syntaxe : solid r dualpolyedreregulier --> solid
%% si le nombre r est present, projette les nouveaux sommets sur la sphere de centre O , de rayon r
/dualpolyedreregulier {
20 dict begin
   dup isnum {
      /r exch def
      /projection true def
   } {
      /projection false def
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   /N solid solidnombresommets def
   /facesaenlever [] def
   %% pour chacun des sommets
   0 1 N 1 sub {
      %% sommet d indice i
      /i exch def
      %% indicesfacesadj = liste des indices des faces ou on trouve le sommet i
      /indicesfacesadj solid i solidfacesadjsommet def
      %% on recupere les centres des faces concernees
      /nouveauxsommets [
         0 1 indicesfacesadj length 1 sub {
            /k exch def 
            solid indicesfacesadj k get solidgetsommetsface isobarycentre3d
         } for
      ] def
      %% et on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G solid i solidgetsommet vecteur3d /vecteurnormal defpoint3d
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      projection {
         %% on projette les sommets sur la sphere
         /nouveauxsommets [ nouveauxsommets {normalize3d r mulv3d} papply3d aload pop ] store
      } if
      %% puis on les rajoute au solide
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% ainsi que la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      /facesaenlever [ facesaenlever aload pop indicesfacesadj aload pop ] store
   } for
   result [0 1 n 1 sub {} for] solidrmfaces
   [N 1 sub -1 0 {} for] {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### newgeode ###
%% syntaxe : solid r newgeode --> solid
%% syntaxe : N r newgeode --> solid
%% N in {3,4,5} -> polyhedre de depart, r = niveau de recursion
/newgeode {
2 dict begin
   /r exch def
   dup issolid not {
      /N exch def
      N 3 eq {
         1 newtetraedre
      } {
         N 4 eq {
            1 newoctaedre
         } {
            1 newicosaedre
         } ifelse
      } ifelse
   } if

   r {
      15 dict begin   
         /solid exch def
         solid dupsolid /result exch def pop
         /n solid solidnombrefaces def
         n 1 sub -1 0 {
            /i exch def
            %% la face d indice i
            solid i solidgetface /F exch def
            /i0 F 0 get def
            /i1 F 1 get def
            /i2 F 2 get def
            solid i0 solidgetsommet /A0 defpoint3d
            solid i1 solidgetsommet /A1 defpoint3d
            solid i2 solidgetsommet /A2 defpoint3d
            A0 A1 milieu3d normalize3d /A01 defpoint3d
            A1 A2 milieu3d normalize3d /A12 defpoint3d
            A2 A0 milieu3d normalize3d /A20 defpoint3d
            result A01 solidaddsommet /i01 exch def
            result A12 solidaddsommet /i12 exch def
            result A20 solidaddsommet /i20 exch def
            result i solidrmface
            result [i0 i01 i20] solidaddface
            result [i01 i1 i12] solidaddface
            result [i01 i12 i20] solidaddface
            result [i20 i12 i2] solidaddface
         } for
         result
      end
   } repeat
end
} def

%% syntaxe : N r newdualgeode --> solid
/newdualgeode {
   newgeode 1
   dualpolyedreregulier
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             quelques solides precalcules           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### newface ### 
%% syntaxe : array newmonoface -> solid
%% ou array = tableau de points 2d
/newmonoface {
4 dict begin
   /table exch def
   /n table length 2 idiv def
   /S table {0} papply def

   /F [
       [0 1 n 1 sub {} for]
   ] def
   S F generesolid
end
} def

%% syntaxe : array newbiface -> solid
%% ou array = tableau de points 2d
/newbiface {
   newmonoface
   dup videsolid
} def

%%%%% ### newpolreg ### 
%% syntaxe : r n newpolreg --> solid
/newpolreg {
5 dict begin
   /n exch def
   /r exch def
   /S [
       0 360 n div 360 360 n div sub {
           /theta exch def
           theta cos r mul
           theta sin r mul
           0
       } for
   ] def
   /F [
       [0 1 n 1 sub {} for]
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newgrille ### 
%% syntaxe : xmin xmax ymin ymax [dx dy] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax [nx ny] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax {mode} newgrille -> solid
%% syntaxe : xmin xmax ymin ymax newgrille -> solid
/newgrille {
10 dict begin
   [[/nx /ny] [1 1] [1. 1.] [1. 1.] [1. 1.] [.5 .5]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /biface false def
   [nx ny] {0} newsurfaceparametree
end
} def

%% %% syntaxe : xmin xmax ymin ymax [dx dy] {f} newsurface -> solid
%% %% f : R^2 -> R
/newsurface { true newsurfaceparametree } def
%
/biface true def
%
/newsurfaceparametree {
10 dict begin
   dup isbool {
      pop /surfz true def
   } {
      /surfz false def
   } ifelse
   /f_surface exch def
   [[/nx /ny] [2 2] [4 4] [1. 1.] [1. 1.] [.25 .25]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def

   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x

   /S [
       0 1 nx {
           /i exch def
           0 1 ny {
               /j exch def
               /u xmin i dx mul add def
               /v ymin j dy mul add def
               u v
               surfz {2 copy} if
               f_surface
               pstrickactionR3
           } for
       } for
   ] def

   /F [
       0 1 nx 1 sub {
          /i exch def
          0 1 ny 1 sub {
             /j exch def
             [
                j 1 add        i ny 1 add mul add
                j              i ny 1 add mul add
                j ny 1 add add i ny 1 add mul add
                j ny 2 add add i ny 1 add mul add
             ]
          } for
       } for
%%       0 1 0 {%nx 1 sub {
%%          /i exch def
%%          0 1 0 {%ny 2 sub {
%%             /j exch def
%%             [
%%             j 1 add        %% i ny mul add
%%             j              %% i ny mul add
%%             ny 1 add j add       %% i ny mul add
%%             ny 2 add j add     %% i ny mul add
%%             ]
%%          } for
%%       } for
   ] def
   S F generesolid
   biface pl@n-en-cours not and {dup videsolid} if
end
} def

%%%%% ### newgrillecirculaire ### 
%% syntaxe : r option newgrillecirculaire -> solid
/newgrillecirculaire {
6 dict begin
   [[/K /N] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode

   %% N = nb de meridiens (diviseur de 360 = 2^4 * 3^2 * 5)
   %% K = nb d horizontales (diviseur de 160 = 2^5 * 5)

   /r exch def
   /F [
       %% 1er etage
       1 1 N {
           /i exch def
           [0 i i N mod 1 add]
       } for
       %% etages suivants
       0 1 K 2 sub {
           /j exch def
           1 1 N {
               /i exch def
               [i      j N mul add
               i N add j N mul add
               i N mod N add 1 add j N mul add
               i N mod 1 add j N mul add]
           } for
      } for
   ] def

   %% tableau des sommets
   /S [
       0 0 0
       1 1 K {
           /j exch def
           1 1 N {
             /i exch def
             /theta i 360 mul N div def
             theta cos r j mul K div mul
             theta sin r j mul K div mul
             0 %2 copy f %exch atan 90 div
          } for
       } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r [dx dy] {f} newsurface* -> solid
/newsurface* {
7 dict begin
   /f_surface exch def
   [[/nx /ny] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode
   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x
   %% ny = nb de meridiens
   %% nx = nb d horizontales
   /r exch def
   /F [
       %% 1er etage
       1 1 ny {
           /i exch def
           [0 i i ny mod 1 add]
       } for
       %% etages suivants
       0 1 nx 2 sub {
           /j exch def
           1 1 ny {
               /i exch def
               [i      j ny mul add
               i ny add j ny mul add
               i ny mod ny add 1 add j ny mul add
               i ny mod 1 add j ny mul add]
           } for
      } for
   ] def
   %% tableau des sommets
   /S [
       0 0 0 0 f_surface
       1 1 nx {
           /j exch def
           1 1 ny {
             /i exch def
             /theta i 360 mul ny div def
             theta cos r j mul nx div mul
             theta sin r j mul nx div mul
             2 copy f_surface 
          } for
       } for
   ] def
   S F generesolid
end
} def

%%%%% ### newruban ### 
%% syntaxe : array h u [n] newruban -> solid d axe (O, u), de maillage vertical n
%% syntaxe : array h u newruban -> solid d axe (O, u),
%% syntaxe : array h newruban -> solid d axe (O, k),
%% ou array tableau de points 2d
/newruban {
7 dict begin
   %% N = nb d etages
   [[/N] [1] [1] [1] [3] [4]] gestionsolidmode
   2 copy pop isarray {
      /u {0 0 1} def
   } {
      /u defpoint3d
   } ifelse
   u 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newruban) ==
      quit
   } if
   pop pop
   /h exch def
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   h u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
     } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newicosaedre ### 
/newicosaedre {
3 dict begin
   /a exch def
   /S [
      0.8944271  0              0.4472137
      0.2763932  0.8506507      0.4472137
      -0.7236067 0.5257311      0.4472137
      -0.7236067 -0.5257311     0.4472137
      0.2763932  -0.8506507     0.4472137
      0          0              1
      0          0              -1
      -0.8944271 0              -0.4472137
      -0.2763932 -0.8506507     -0.4472137
      0.7236067  -0.5257311     -0.4472137
      0.7236067  0.5257311      -0.4472137
      -0.2763932 0.8506507      -0.4472137
   ] {a mulv3d} papply3d def

   /F [
      [0 1 5]   %% 1  2 6  ]
      [1 2 5]   %% 2  3 6  ]
      [2 3 5]   %% 3  4 6  ]
      [3 4 5]   %% 4  5 6  ]
      [4 0 5]   %% 5  1 6  ]
      [9 0 4]   %% 10 1 5  ]
      [0 9 10]  %% 1  10 11]
      [10 1 0]  %% 11 2 1  ]
      [1 10 11] %% 2  11 12]
      [11 2 1]  %% 12 3 2  ]
      [2 11 7]  %% 3  12 8 ]
      [2 7 3]   %% 3  8 4  ]
      [3 7 8]   %% 4  8 9  ]
      [3 8 4]   %% 4  9 5  ]
      [4 8 9]   %% 5  9 10 ]
      [6 7 11]  %% 7  8 12 ]
      [6 8 7]   %% 7  9 8  ]
      [6 9 8]   %% 7  10 9 ]
      [6 10 9]  %% 7  11 10]
      [6 11 10] %% 7  12 11]
   ] def

   S F generesolid
end
} def

%%%%% ### newdodecaedre ### 
/newdodecaedre {
3 dict begin
   /a exch def
   /S [
      0          0.607062   0.7946545
      -0.5773503 0.1875925  0.7946545
      -0.3568221 -0.4911235 0.7946545
      0.3568221  -0.4911235 0.7946545
      0.5773503  0.1875925  0.7946545
      0          0.982247   0.1875925
      -0.9341724 0.303531   0.1875925
      -0.5773503 -0.7946645 0.1875925
      0.5773503  -0.7946645 0.1875925
      0.9341724  0.303531   0.1875925
      0          -0.982247  -0.1875925
      0.9341724  -0.303531  -0.1875925
      0.5773503  0.7946545  -0.1875925
      -0.5773503 0.7946545  -0.1875925
      -0.9341724 -0.303531  -0.1875925
      -0.5773503 -0.1875925 -0.7946545
      -0.3568221 0.4911235  -0.7946545
      0.3568221  0.4911235  -0.7946545
      0.5773503  -0.1875925 -0.7946545
      0          -0.607062  -0.7946545
   ] {a mulv3d} papply3d def

   /F [
      [0 1 2 3 4]
      [4 3 8 11 9]
      [4 9 12 5 0]
      [0 5 13 6 1]
      [1 6 14 7 2]
      [2 7 10 8 3]
      [10 19 18 11 8]
      [11 18 17 12 9]
      [12 17 16 13 5]
      [13 16 15 14 6]
      [14 15 19 10 7]
      [15 16 17 18 19]
   ] def
   S F generesolid
end
} def

%%%%% ### newoctaedre ### 
/newoctaedre {
3 dict begin
   /a exch def
   %%Sommets
   /S [
      0  0  1
      1  0  0
      0  1  0
      -1 0  0
      0  -1 0
      0  0  -1
   ] {a mulv3d} papply3d def

   /F [
      [0 4 1]
      [1 2 0]
      [0 2 3]
      [3 4 0]
      [1 5 2]
      [2 5 3]
      [3 5 4]
      [4 5 1]
   ] def

   S F generesolid
end
} def

%%%%% ### newtetraedre ### 
/newtetraedre {
3 dict begin
   /r exch def
   %%Tetraedre
   /S [
      0          0          1
      -0.4714045 -0.8164965 -1 3 div
      0.942809   0          -1 3 div
      -0.4714045 0.8164965  -1 3 div
   ] {r mulv3d} papply3d def

   /F [
      [0 1 2]
      [0 2 3]
      [0 3 1]
      [1 3 2]
   ] def

   S F generesolid
end
} def

%%%%% ### newcube ### 
/newcube {
3 dict begin
   [[/n] [1] [1] [1] [3] [4]] gestionsolidmode
   /a exch 2 div def

   n 1 le {
      /F [
     [0 1 2 3]
     [0 4 5 1]
     [1 5 6 2]
     [2 6 7 3]
     [0 3 7 4]
     [4 7 6 5]
      ] def

      %% tableau des sommets
      /S [
      1  1  1 %% 0
     -1  1  1 %% 1
     -1 -1  1 %% 2
      1 -1  1 %% 3
      1  1 -1 %% 4
     -1  1 -1 %% 5
     -1 -1 -1 %% 6
      1 -1 -1 %% 7
      ] {a mulv3d} papply3d def
      S F generesolid
   } {
      /dl 2 n div def
      /N n dup mul n add 4 mul def
      /n1 n 1 sub dup mul def %% nb sommets centre d une face

      %% tableau des sommets
      /S1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n {
           /i exch def
           -1 i dl mul add
           -1 j dl mul add
        1
        } for
     } for
      ] def

      /S2 S1 {-90 0 0 rotateOpoint3d} papply3d def
      /S3 S2 {-90 0 0 rotateOpoint3d} papply3d def
      /S4 S3 {-90 0 0 rotateOpoint3d} papply3d def

      /S5 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
        1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      /S6 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
           -1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      %% tableau des faces
      /F1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n 1 sub {
           /i exch def
           [
          i n 1 add j mul add
          dup 1 add
          dup n 1 add add
          dup 1 sub
           ]
        } for
     } for
      ] def

      %% syntaxe : i sommettourgauche --> l indice du i-eme sommet du tour
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourgauche {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourgauche) ==
        exit
     } if
     n n 1 add i mul add
      end
      } def

      %% syntaxe : i sommetcentregauche --> l indice du i-eme sommet du centre
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentregauche {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentregauche) ==
        exit
     } if
     N i add
      end
      } def

      /F5 [
     %%%%% la face gauche %%%%%
     %% le coin superieur gauche
     [
        1 sommettourgauche
        0 sommettourgauche
        n 4 mul 1 sub sommettourgauche
        n1 n 1 sub sub sommetcentregauche
     ]

     %% la bande superieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i 1 add sommettourgauche
           i sommettourgauche
           n1 n sub i add sommetcentregauche
           n1 n sub i 1 add add sommetcentregauche
        ]
     } for

     %% le coin superieur droit
     [
        n sommettourgauche
        n 1 sub sommettourgauche
        n1 1 sub sommetcentregauche
        n 1 add sommettourgauche
     ]

     %% la descente gauche
     %% j from 1 to n-2
     1 1 n 2 sub {
        /j exch def
        [
           n1 n 1 sub j mul sub sommetcentregauche
           n 4 mul j sub sommettourgauche
           n 4 mul j 1 add sub sommettourgauche
           n1 n 1 sub j 1 add mul sub sommetcentregauche
        ]
     } for

     %% les bandes centrales (j from 1 to n-2 et i from 1 to n-2)
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n1 i n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j mul add sub sommetcentregauche
          n1 i n 1 sub j mul add sub sommetcentregauche
           ]
        } for
     } for

     %% la descente droite
     1 1 n 2 sub {
        /j exch def
        [
           n j add sommettourgauche
           n1 1 sub j 1 sub n 1 sub mul sub sommetcentregauche
           n1 1 sub j n 1 sub mul sub sommetcentregauche
           n j 1 add add sommettourgauche
        ]
     } for

     %% le coin inferieur gauche
     [
        0 sommetcentregauche
        n 3 mul 1 add sommettourgauche
        n 3 mul sommettourgauche
        n 3 mul 1 sub sommettourgauche
     ]

     %% la bande inferieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i sommetcentregauche
           i 1 sub sommetcentregauche
           n 3 mul i sub sommettourgauche
           n 3 mul i sub 1 sub sommettourgauche
        ]
     } for

     %% le coin inferieur droit
     [
        n 2 mul 1 sub sommettourgauche
        n 2 sub sommetcentregauche
        n 2 mul 1 add sommettourgauche
        n 2 mul sommettourgauche
     ]
      ] def

      %% syntaxe : i sommettourdroit --> l indice du i-eme sommet du tour
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourdroit {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourdroit) ==
        exit
     } if
     n 1 add i mul
      end
      } def

      %% syntaxe : i sommetcentredroit --> l indice du i-eme sommet du centre
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentredroit {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentredroit) ==
        exit
     } if
     N n1 add i add
      end
      } def

      /F6 [
     %% coin superieur droit
     [
        0 sommettourdroit
        1 sommettourdroit
        n1 n 1 sub sub sommetcentredroit
        4 n mul 1 sub sommettourdroit
     ]
     %% coin superieur gauche
     [
        n 1 sub sommettourdroit
        n sommettourdroit
        n 1 add sommettourdroit
        n1 1 sub sommetcentredroit
     ]
     %% coin inferieur gauche
     [
        n 2 sub sommetcentredroit
        2 n mul 1 sub sommettourdroit
        2 n mul sommettourdroit
        2 n mul 1 add sommettourdroit
     ]
     %% coin inferieur droit
     [
        3 n mul 1 add sommettourdroit
        0 sommetcentredroit
        3 n mul 1 sub sommettourdroit
        3 n mul sommettourdroit
     ]
     %% bande superieure
     1 1 n 2 sub {
        /i exch def
        [
           i sommettourdroit
           i 1 add sommettourdroit
           n 1 sub n 2 sub mul i add sommetcentredroit
           n 1 sub n 2 sub mul i 1 sub add sommetcentredroit
        ]
     } for
     %% bande inferieure
     1 1 n 2 sub {
        /i exch def
        [
           i 1 sub sommetcentredroit
           i sommetcentredroit
           3 n mul 1 sub i sub sommettourdroit
           3 n mul i sub sommettourdroit
        ]
     } for
     %% descente gauche
     1 1 n 2 sub {
        /i exch def
        [
           n1 1 sub i 1 sub n 1 sub mul sub sommetcentredroit
           n i add sommettourdroit
           n i 1 add add sommettourdroit
           n1 1 sub i n 1 sub mul sub sommetcentredroit
        ]
     } for
     %% descente droite
     1 1 n 2 sub {
        /i exch def
        [
           4 n mul i sub sommettourdroit
           n 1 sub n 1 sub i sub mul sommetcentredroit
           n 1 sub n 2 sub i sub mul sommetcentredroit
           4 n mul i sub 1 sub sommettourdroit
        ]
     } for
     %% bandes interieures
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n 1 sub j mul i 1 sub add sommetcentredroit
          n 1 sub j mul i add sommetcentredroit
          n 1 sub j 1 sub mul i add sommetcentredroit
          n 1 sub j 1 sub mul i 1 sub add sommetcentredroit
           ]
        } for
     } for

      ] def

      /F2 F1 {{n dup mul n add add} apply} apply def
      /F3 F2 {{n dup mul n add add} apply} apply def
      /F4 F3 {{n dup mul n add add} apply} apply def


      S1 S2 append S3 append S4 append S5 append S6 append {a mulv3d} papply3d
      F1 F2 append F3 append F4 append {{N mod} apply} apply F5 append F6 append
      generesolid
   } ifelse
end
} def

%%%%% ### newparallelepiped ### 
% 14 octobre 2006
/newparallelepiped {
2 dict begin
   /c exch 2 div def
   /b exch 2 div def
   /a exch 2 div def
   /F [
      [0 1 2 3]
      [0 4 5 1]
      [1 5 6 2]
      [2 6 7 3]
      [0 3 7 4]
      [4 7 6 5]
    ] def

    %% tableau des sommets
    /S [
       a     b     c %% 0
       a neg b     c %% 1
       a neg b neg c %% 2
       a     b neg c %% 3
       a     b     c neg %% 4
       a neg b     c neg %% 5
       a neg b neg c neg %% 6
       a     b neg c neg %% 7
    ] def
    S F generesolid
end
} def

%%%%% ### newcylindre ### 
%% syntaxe : z0 r0 z1 newcylindre -> solide
%% syntaxe : z0 r0 z1 {mode} newcylindre -> solide
%% syntaxe : z0 r0 z1 [n1 n2] newcylindre -> solide
%% syntaxe : a b {f} {u} h [n1 n2] newcylindre
/newcylindre {
2 dict begin
   [[/n2 /n1] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode
   2 copy pop xcheck {
      %% cylindre cas general
      /h exch def
      /U exch def
      U normalize3d /u defpoint3d
      /lafonction exch def
      /b exch def
      /a exch def
      /pas b a sub n1 div def
      /vpas h n2 div def
      /S [
         0 1 n2 {
            /j exch def
            0 1 n1 {
               /i exch def
               a i pas mul add lafonction
               u j vpas mul mulv3d addv3d
            } for
         } for
      ] def
      /F [
         0 1 n2 1 sub {
            /j exch def
            0 1 n1 1 sub {
               /i exch def
               [
                  i n1 1 add j mul add 
                  dup 1 add
                  dup n1 1 add add
                  dup 1 sub
               ]
            } for
         } for
      ] def
      
      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      2 copy pop [n2 n1] newtronccone
   } ifelse
end
} def

%% syntaxe : z0 r0 z1 newcylindrecreux -> solide
/newcylindrecreux {
   newcylindre
   dup creusesolid
} def

%%%%% ### newtronccone ### 
%% syntaxe : z0 r0 z1 r1 newtronccone -> solid
/newtronccone {
11 dict begin
   [[/n /N] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode

   /r1 exch def
   /z1 exch def
   /r0 exch def
   /z0 exch def
   /dz z1 z0 sub n div def
   /dr r1 r0 sub n div def

   /FE [
      [0 1 N 1 sub {} for]
      [n 1 add N mul 1 sub -1 n N mul {} for]

      0 1 n 1 sub {
      /k exch def
         k N mul 1 add 1 k 1 add N mul 1 sub {
             /i exch def
             [i i 1 sub N i add 1 sub N i add]
         } for
         [k N mul k 1 add N mul 1 sub k 2 add N mul 1 sub k 1 add N mul]
      } for

   ] def

   %% tableau des sommets
   /S [
      n -1 0 {
         /k exch def
         0 1 N 1 sub {
             /i exch def
             360 N idiv i mul cos r0 dr k mul add mul
             360 N idiv i mul sin r0 dr k mul add mul
             z0 dz k mul add
         } for
      } for
   ] def
   S FE generesolid
end
} def

%% syntaxe : z0 r0 z1 r1 newtroncconecreux -> solid
/newtroncconecreux {
   newtronccone
   dup creusesolid
} def

%%%%% ### newcone ### 
%% syntaxe : z0 r0 z1 newcone -> solid
%% syntaxe : z0 r0 z1 {mode} newcone -> solid
%% syntaxe : z0 r0 z1 [n1 n2] newcone -> solid
%% syntaxe : a b {f} {sommet} [n1 n2] newcone -> solid
/newcone {
11 dict begin
   [ [/n /N] [1 6] [1 8] [1 10] [3 12] [5 18] ] gestionsolidmode
   dup xcheck {
      %% cas general
      /sommet exch def
      /lafonction exch def
      /b exch def
      /a exch def

      /pas b a sub N div def
      /S [
         sommet
         0 1 n 1 sub {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               dupp3d sommet vecteur3d j n div mulv3d addv3d
            } for
         } for
         1 1 n {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               sommet vecteur3d j n div mulv3d sommet addv3d
            } for
         } for
      ] def

      /F [
         %% les etages inferieurs
         0 1 n 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
         %% dernier etage inferieur
         1 1 N {
            /i exch def
            [
               i N 1 add n 1 sub mul add
               dup 1 add
               0
            ]
         } for
         %% premier etage superieur
         1 1 N {
            /i exch def
            [
               i N 1 add n mul add
               dup 1 add
               0
               exch
            ]
         } for
         %% les etages superieurs
         n 1 n 2 mul 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
      ] def

      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      /z1 exch def
      /r0 exch def
      /z0 exch def
      /dz z1 z0 sub n div def
      /dr r0 n div def
   
      /F [
         %% la base
         [N 1 sub -1 0 {} for]
         %% le dernier etage
         n 1 sub N mul 1 add 1 n N mul 1 sub {
              /i exch def
              [i 1 sub i n N mul]
         } for
         [n N mul 1 sub n 1 sub N mul n N mul]
         %% les autres etages
         0 1 n 2 sub {
            /j exch def
            0 N j mul add 1 N N j mul add 2 sub {
               /i exch def
               [i i 1 add dup N add dup 1 sub]
            } for
            [N N j mul add 1 sub N j mul dup N add dup N add 1 sub]
         } for
      ] def
   
      %% tableau des sommets
      /S [
         %% etage no j (in [1; n])
         0 1 n 1 sub {
            /j exch def
            0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r0 dr j mul sub mul
                360 N idiv i mul sin r0 dr j mul sub mul
                z0 dz j mul add
            } for
         } for
         0 0 z1
      ] def
      S F generesolid
   } ifelse
end
} def

%% %% syntaxe : z0 r0 z1 newconecreux -> solid
 /newconecreux {
    newcone
    dup 0 solidrmface
    dup videsolid
 } def

%%%%% ### newtore ### 
%% syntaxe : r R newtore -> solid
/newtore {
10 dict begin
   [[/n1 /n2] [4 5] [6 10] [8 12] [9 18] [18 36]] gestionsolidmode
   /n2 n2 3 max store
   /n1 n1 2 max store
   /R exch def
   /r exch def
   /S [
         0 1 n1 1 sub {
            /i exch def
            360 n1 div i mul cos r mul R add
            360 n1 div i mul sin r mul
         } for
      ]
   def
   S [n2] newanneau
end
} def

%%%%% ### newprisme ### 
%% syntaxe : array z0 z1 newprisme -> solid d axe (O, u),
/newprismedroit {
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   0 0 1 [N] newprisme
} def

%% syntaxe : array z0 z1 u newprisme -> solid d axe (O, u),
%% ou array tableau de points 2d
/newprisme {
7 dict begin
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   dup 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newprisme) ==
      quit
   } if
   /u defpoint3d
   /z1 exch def
   /z0 exch def
   %% N = nb d etages
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   z1 z0 sub u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             z0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [ 
      %% face superieure
      [0 1 n {} for]
      %% base
      [N 1 add n 1 add mul 1 sub -1 N n 1 add mul {} for]
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
         [0            j 1 sub n 1 add mul add
         n             j 1 sub n 1 add mul add
         2 n mul 1 add j 1 sub n 1 add mul add
         n 1 add       j 1 sub n 1 add mul add]
     } for
   ] def

   S F generesolid
end
} def

%%%%% ### newsphere ### 
%% syntaxe : r option newsphere -> solid
/newsphere {
2 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode
   -90 90 [K N] newcalottesphere
end
} def

%% syntaxe : r phi theta option newcalottesphere -> solid
/newcalottesphere {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r phi theta option newcalottespherecreuse -> solid
/newcalottespherecreuse {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
%        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
%         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newanneau ### 
%% syntaxe : array n newanneau --> solid
%% syntaxe : array {mode} newanneau --> solid
%% ou array est un tableau de points de R^2 et n un nombre entier positif
/newanneau {
10 dict begin
   dup isnum {
      /n exch def
      [n]
   } if
   [[/n2] [6] [12] [24] [32] [36]] gestionsolidmode
   /n2 n2 3 max store
   %% on plonge la section dans R^3 par projection sur yOz
   /S1 exch {0 3 1 roll} papply def
   %% nombre de sommets
   /n1 S1 length 3 idiv def

   /S S1
      n2 {
         duparray
         {0 0 360 n2 div rotateOpoint3d} papply3d
      } repeat
      n2 {append} repeat
   def

   /F [
      0 1 n2 1 sub {
         /j exch def
         n1 j mul 1 j 1 add n1 mul 2 sub {
            /i exch def
            [i 1 add i dup n1 add i n1 1 add add]
         } for
         [n1 j mul j 1 add n1 mul 1 sub j 2 add n1 mul 1 sub j 1 add n1 mul]
      } for
   ] def

   S F generesolid
end
} def

%%%%% ### newvecteur ### 
%% syntaxe : x y z newvecteur
%% syntaxe : x y z array newvecteur
/newvecteur {
4 dict begin
   dup isarray {
      /table exch def
      /h@uteur table 1 get def
      /r@y@n table 0 get def
   } {
      /h@uteur .3 def
      /r@y@n .1 def
   } ifelse
   /A defpoint3d
   %%Sommets
   /S [0 0 0 A] def
   /F [
      [0 1]
   ] def
   S F generesolid
   [ A ]
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d

   A norme3d /z exch h@uteur sub def 
   0 r@y@n h@uteur [1 8] newcone
   dup (noir) outputcolors
   {0 0 z translatepoint3d} solidtransform
   {imI imJ imK transformpoint3d} solidtransform
   solidfuz
end
} def

%%%%% ### readsolidfile ###
%% syntaxe : str readsolidfile -> solid
/readsolidfile {
1 dict begin
   /str exch def
   [str (-sommets.dat) append run] 
   [str (-faces.dat) append run]
   generesolid
   dup [str (-couleurs.dat) append run] solidputfcolors
   dup [str (-io.dat) append run] solidputinouttable
end
} def

%%%%% ### writesolidfile ###
%% syntaxe : solid str writesolidfile -> -
/writesolidfile {
10 dict begin
   /str exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans writesolidfile) ==
      quit
   } if
   str (-sommets.dat) append (w) file /lefichiersommets exch def
   str (-faces.dat) append (w) file /lefichierfaces exch def
   str (-couleurs.dat) append (w) file /lefichiercouleurs exch def
   str (-io.dat) append (w) file /lefichierio exch def

   /S solid solidgetsommets def
   0 1 S length 3 idiv 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichiersommets x chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets y chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets z chaine cvs writestring
      lefichiersommets 10 write %% CR
   } for
   lefichiersommets closefile

   /F solid solidgetfaces def
   0 1 F length 1 sub {
      /i exch def
      /Fi solid i solidgetface def
      lefichierfaces 91 write %% [
      0 1 Fi length 1 sub {
         /j exch def
         lefichierfaces Fi j get chaine cvs writestring
         lefichierfaces 32 write %% espace
      } for
      lefichierfaces 93 write %% ]
      lefichierfaces 10 write %% CR
   } for
   lefichierfaces closefile

   /C solid solidgetfcolors def
   0 1 C length 1 sub {
      /i exch def
      lefichiercouleurs 40 write %% (
      lefichiercouleurs C i get writestring
      lefichiercouleurs 41 write %% )
      lefichiercouleurs 10 write %% CR
   } for
   lefichiercouleurs closefile

   /IO solid solidgetinouttable def
   0 1 3 {
      /i exch def
      lefichierio IO i get chaine cvs writestring
      lefichierio 32 write %% space
   } for
   lefichierio closefile
end
} def

%%%%% ### writeobjfile ###
%% syntaxe : solid str writeobjfile -> -
/writeobjfile {
10 dict begin
   /str exch (.obj) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeobjfile) ==
      quit
   } if
   /n solid solidnombresommets def
   str (w) file /lefichier exch def
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier (v ) writestring
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      lefichier (f ) writestring
      /F solid i solidgetface {1 add} apply def
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### writeofffile ###
%% syntaxe : solid str writeobjfile -> -
/writeofffile {
12 dict begin
   /str exch (.off) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeofffile) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def
   str (w) file /lefichier exch def
   lefichier (OFF) writestring
   lefichier 10 write %% CR
   lefichier n chaine cvs writestring
   lefichier 32 write %% espace
   lefichier nf chaine cvs writestring
   lefichier 32 write %% espace
   lefichier 0 chaine cvs writestring
   lefichier 10 write %% CR
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   0 1 nf 1 sub {
      /i exch def
      /F solid i solidgetface def
      lefichier F length chaine cvs writestring
      lefichier 32 write %% espace
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### newobjfile ###
/newobjfile {
3 dict begin
   /objfilename exch (.obj) append def
   /v {} def
   /ok true def
   /f {
       ok {
        %% 1ere fois
           ] %% ferme les sommets
        [ [ %% ouvre les faces
        /ok false store
       } {
        %% les autres fois
           ] %% ferme la face
        [ %% ouvre la nouvelle
       } ifelse
   } def
   [ 0 0 0 %% sommet fantome pour respecter l'indexation (a partir de l'indice 1)
   objfilename run
   ]]
   /F exch def
   /S exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newofffile ###
/newofffile {
3 dict begin
   /str 35 string def
   /offfilename exch (.off) append def
   offfilename (r) file
   /offfile exch def
   offfile str readline pop pop
   offfile str readline pop
   numstr2array
   dup 0 get /ns exch def
   1 get /nf exch def
   [ns {
      offfile str readline pop numstr2array aload pop
%      3 1 roll
   } repeat]
   /S exch def
   [nf {
      [
      offfile str readline pop numstr2array
      /table exch def
      1 1 table length 1 sub {
         /i exch def
         table i get
      } for
      ]
   } repeat]
   /F exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newtube ###
 /tub@dernierk1 [1 0 0] def
 /tub@dernierk2 [0 1 0] def
 /tub@dernierk3 [0 0 1] def

/inittube {
2 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   vect1 norme3d 0 eq {
      vect2 vect3 vectprod3d /vect1 defpoint3d
   } if
   vect2 norme3d 0 eq {
      vect3 vect1 vectprod3d /vect2 defpoint3d
   } if
   vect3 norme3d 0 eq {
      vect1 vect2 vectprod3d /vect3 defpoint3d
   } if
   /tub@dernierk1 [vect1] store
   /tub@dernierk2 [vect2] store
   /tub@dernierk3 [vect3] store
end
} def
 
%% syntaxe : tmin tmax (f) array r newtube -> solid
%% array = [K N]
/newtube {
10 dict begin
   /table exch def
   /K table 0 get def %% nb d etages
   /N table 1 get def %% nb de points sur le perimetre
   /@r exch def       %% le rayon du tube
   /str exch def
   /lafonction str cvx def
   /laderivee str (') append cvx def
%%   /laderivee2nd str ('') append cvx def
   /tmax exch def
   /tmin exch def
   /pas tmax tmin sub K 1 sub div def

   %% definition des sommets
   [
   /@k 0 def
   K {
      /a0 tmin @k pas mul add def
   
      %% definition du repere de Frenet (k1, k2, k3) au point f(a)
      a0 lafonction /M defpoint3d

      str (') append cvlit where {
         pop 
         a0 laderivee normalize3d /k1 defpoint3d
%         pop /avecderiv true def
      } {
         M a0 pas 100 div add lafonction vecteur3d normalize3d /k1 defpoint3d
%         /avecderiv false
      } ifelse

      k1 baseplannormal /K3 defpoint3d /K2 defpoint3d
%      a0 laderivee2nd normalize3d /k2 defpoint3d

      %% projete orthogonal du dernier rayon sur le plan actuel
      %% (normal a la vitesse)
      K2 tub@dernierk2 aload pop K2 scalprod3d mulv3d 
      K3 tub@dernierk2 aload pop K3 scalprod3d mulv3d addv3d /k2 defpoint3d
%      M k1 K2 K3 dessinebase
      k1 norme3d 0 eq {
         tub@dernierk1 aload pop /k1 defpoint3d
      } {
         /tub@dernierk1 [k1] store
      } ifelse
      k2 norme3d 0 eq {
         tub@dernierk2 aload pop /k2 defpoint3d
      } {
         /tub@dernierk2 [k2] store
      } ifelse
      k1 k2 vectprod3d normalize3d /k3 defpoint3d
      k3 norme3d 0 eq {
          tub@dernierk3 aload pop /k3 defpoint3d
      } {
         /tub@dernierk3 [k3] store
      } ifelse
      k3 k1 vectprod3d normalize3d /k2 defpoint3d
%%      M k1 k2 k3 dessinebase
      /tub@dernierk2 [k2] store
      /@n 360 N div def %% le pas angulaire
      0 @n 360 @n sub {
         /@i exch def
         M
         k2 @i cos @r mul mulv3d addv3d
         k3 @i sin @r mul mulv3d addv3d
      } for
      /@k @k 1 add store
   } repeat
   ]

   dup length 3 idiv /nb exch def
   %% definition des faces
   [
      %% face de depart
      [N 1 sub -1 0 {} for]
      %% face d arrivee
      [nb 1 sub N 1 sub {dup 1 sub} repeat] reverse
   
      %% les etages
      /j 0 def
      K 1 sub {
         0 1 N 1 sub {
            /i exch def
            [
               i                   N j mul add
               i 1 add N mod       N j mul add
               i 1 add N mod N add N j mul add
               i N add             N j mul add
            ]
         } for
         /j j 1 add store
      } repeat
   ]
   generesolid
end
} def

%%%%% ### newcourbe ###
%% syntaxe : a b {f} array newcourbe --> solid
/newcourbe {
10 dict begin
   dup xcheck not {
      0 get /n exch def
   } {
      /n 80 def
   } ifelse
   /l@f@nct exch def
   /b exch def
   /a exch def
   /pas b a sub n 1 sub div def
   /S [
   0 1 n 1 sub {
      /@i exch def
      a @i pas mul add
      l@f@nct
      pstrickactionR3
   } for
   ] def
   /@F [
      0 1 n 2 sub {
         /@i exch def
         [@i @i 1 add]
      } for
   ] def
   S @F generesolid
end
} def

%%%%% ### baseplannormal ###
%% syntaxe : x y z baseplannormal -> x1 y1 z1 x2 y2 z2
/baseplannormal {
5 dict begin
   /K defpoint3d
   1 0 0 K vectprod3d normalize3d /U defpoint3d
   U norme3d 0 eq {
      0 1 0 K vectprod3d normalize3d /U defpoint3d
   } if
   K U vectprod3d normalize3d /V defpoint3d
   U V
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%      fin insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          gestion de chaine de caracteres           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/Times-Roman findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end
/Times-Roman-ISOLatin1 exch definefont pop

/setTimesRoman {
   /Times-Roman-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

/setTimes {
   setTimesRoman
} def

%% syntaxe : string x y cctext
/cctext {
5 dict begin
   /y exch def
   /x exch def
   /str exch def
   str stringwidth
   /wy exch def
   /wx exch def
   gsave
      x y smoveto
      wx -2 div wy -2 div rmoveto
      str show
   grestore
end
} def

/dbtext {gsave newpath dbtext_ Fill grestore} def
/dctext {gsave newpath dctext_ Fill grestore} def
/dltext {gsave newpath dltext_ Fill grestore} def
/drtext {gsave newpath drtext_ Fill grestore} def

/bbtext {gsave newpath bbtext_ Fill grestore} def
/bctext {gsave newpath bctext_ Fill grestore} def
/bltext {gsave newpath bltext_ Fill grestore} def
/brtext {gsave newpath brtext_ Fill grestore} def

/cbtext {gsave newpath cbtext_ Fill grestore} def
/cctext {gsave newpath cctext_ Fill grestore} def
/cltext {gsave newpath cltext_ Fill grestore} def
/crtext {gsave newpath crtext_ Fill grestore} def

/ubtext {gsave newpath ubtext_ Fill grestore} def
/uctext {gsave newpath uctext_ Fill grestore} def
/ultext {gsave newpath ultext_ Fill grestore} def
/urtext {gsave newpath urtext_ Fill grestore} def


%% syntaxe : str x y show_dim --> str x y llx lly wx wy 
%% attention, doit laisser la pile intacte
/show_dim {
   3 copy pop pop
   newpath
      0 0 moveto
      true charpath flattenpath pathbbox 
   closepath
   newpath
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour PSTricks               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% les 3 procedures utilisees pour transformer les depots de AlgToPs en nombres
/pstrickactionR3 { 
3 dict begin 
  /len@3 exch def 
  /len@2 exch def 
  /len@1 exch def 
  len@1 exec 
  len@2 exec 
  len@3 exec 
end 
} def 

/pstrickactionR2 {
   exec exch exec exch
} def

/pstrickactionR {
   exec
} def

/gere_pst-deffunction {
   counttomark
   dup 1 eq {
      pop
      pstrickactionR
      ] aload pop
   } {
      2 eq {
         pstrickactionR2
         ] aload pop
      } {
         pstrickactionR3
         ] aload pop
      } ifelse
   } ifelse
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour \psSolid               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/all (all) def

/draw {drawsolid} def
/draw* {drawsolid*} def
/draw** {drawsolid**} def
/writeobj {solidfilename writeobjfile} def
/writesolid {solidfilename writesolidfile} def
/writeoff {solidfilename writeofffile} def
/none {pop} def
/vecteur_en_c@urs false def

/gere_pstricks_color_inout {
   gsave
      dup  [fillincolor] (setrgbcolor) astr2str
         [fillcolor] (setrgbcolor) astr2str inoutputcolors
   grestore
} def

/gere_pstricks_color_out {
   gsave
      dup  [fillcolor] (setrgbcolor) astr2str outputcolors
   grestore
} def

/gere_pstfont {
   fontsize mul setfontsize
   %setTimes
   PSfont dup /Symbol ne isolatin and {
      /ISO-Font ReEncode /ISO-Font
   } if
   findfont fontsize scalefont setfont
} def

/gere_pstricks_opt {
%   /CourbeR2 {CourbeR2+} def
   1 gere_pstfont
   linecolor
   linestyle
   solidlinewidth setlinewidth
   solidtrunc length 0 ne {
      solidtrunc 0 get isstring {
         dup trunccoeff solidtronque
      } {
         dup solidtrunc trunccoeff solidtronque
      } ifelse
   } if
   solidgeode {
      1 newgeode
   } if
   soliddualreg {
      dualpolyedreregulier
   } if
   chanfrein {
      dup chanfreincoeff solidchanfreine
   } if
   RotX 0 ne RotY 0 ne or RotZ 0 ne or {
      {RotX RotY RotZ rotateOpoint3d} solidtransform
   } if
   CX 0 ne CY 0 ne or CZ 0 ne or {
      {CX CY CZ translatepoint3d} solidtransform
   } if
   plansection length 0 gt {
      0 1 plansection length 1 sub {
         /i exch def
         plansection i get solidplansection
         dup 0 solidrmface
      } for
   } if
   /rmfaces rmfaces bubblesort reverse store
   0 1 rmfaces length 1 sub {
      /i exch def
      dup rmfaces i get solidrmface
   } for
   tx@Dict /pst-transformoption known {
      dup {pst-transformoption} solidtransform 
   } if
   solidaffinage length 0 ne {
      %% si on affine, il faut colorier avant
      activationgestioncouleurs {
         gere_pstricks_color_out
      } if
      solidaffinage 0 get isstring {
         dup affinagecoeff
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } {
         dup affinagecoeff solidaffinage
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } ifelse
      %% et il faut evider et coloriier l'interieur si necessaire
      solidhollow {
         dup videsolid
         activationgestioncouleurs {
            gsave
               dup  [fillincolor] (setrgbcolor) astr2str inputcolors
            grestore
         } if
      } if
      /activationgestioncouleurs false def
   } if
   tx@Dict /plansepare known {
      plansepare solidplansepare
      tx@Dict /plansepare undef
      tx@Dict /solidname known {
         solidname (1) append cvlit exch def
         dup solidname (0) append cvlit exch def
         %%
         solidname (1) append cvx exec
         solidhollow {
            dup videsolid
         } if
         activationgestioncouleurs {
            dup solidwithinfaces {
               gere_pstricks_color_inout 
            } {
               gere_pstricks_color_out
            } ifelse
         } if
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
         pop
         tx@Dict /solidname undef
      } {
         /solid1 exch def
         /solid2 exch def
      } ifelse
   } if
   solidhollow {
      dup videsolid
   } if
   activationgestioncouleurs {
      zcolor length 0 ne {
         dup zcolor tablez solidcolorz 
      } {
         dup solidwithinfaces {
            gere_pstricks_color_inout 
         } {
            gere_pstricks_color_out
         } ifelse
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
      } ifelse
   } {
      /activationgestioncouleurs true def
   } ifelse

   0 1 fcol length 2 idiv 1 sub {
      /i exch def 
      dup fcol 2 i mul get fcol 2 i mul 1 add get solidputfcolor
   } for
   vecteur_en_c@urs not {
      /lightsrc where {pop solidlightOn} if
   } {
      /vecteur_en_c@urs false def
   } ifelse
   dup action cvx exec
   noir
   solidnumf length 0 ne {
      solidnumf 0 get isstring {
         dup projectionsifacevisible solidnumfaces
      } {
         dup solidnumf projectionsifacevisible solidnumfaces
      } ifelse
   } if
   solidshow length 0 ne {
      solidshow 0 get isstring {
         dup solidshowsommets
      } {
         dup solidshow solidshowsommets
      } ifelse
   } if
   solidnum length 0 ne {
      solidnum 0 get isstring {
         .8 gere_pstfont
         dup solidnumsommets
      } {
         dup solidnum solidnumsommets
      } ifelse
   } {
      %% pop
   } ifelse
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def

/pst-octahedron {
   a newoctaedre
   gere_pstricks_opt
} def

/pst-dodecahedron {
   a newdodecaedre
   gere_pstricks_opt
} def

/pst-icosahedron {
   a newicosaedre
   gere_pstricks_opt
} def

/pst-cube {
   a
   ngrid length 1 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcube 
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-parallelepiped {
   a b c
   newparallelepiped
   gere_pstricks_opt
} def

/pst-tetrahedron {
   r newtetraedre
   gere_pstricks_opt
} def

/pst-tore {
   r0 r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtore
   gere_pstricks_opt
} def

/pst-sphere {
   % rayon
   % mode
  %   r {Mode} newsphere
   r
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newsphere
   gere_pstricks_opt
} def
%
/pst-cylindre {
   /save-cylinderhollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {axe} h ngrid newcylindre
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      newcylindre
      solidhollow {
         dup creusesolid
      } if
   } ifelse
   gere_pstricks_opt
   /solidhollow save-cylinderhollow store
} def
%
/pst-cylindrecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcylindre
   dup creusesolid
   gere_pstricks_opt
} def

/pst-cone {
   /save-conehollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {origin} ngrid newcone
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      solidhollow {
         newconecreux
      } {
         newcone
      } ifelse
   } ifelse
   gere_pstricks_opt
   /solidhollow save-conehollow store
} def

/pst-tronccone {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newtroncconecreux
   } {
      newtronccone
   } ifelse
   gere_pstricks_opt
} def

/pst-troncconecreux {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtroncconecreux
   gere_pstricks_opt
} def

/pst-conecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newconecreux
   gere_pstricks_opt
} def

/pst-anneau {
   [ section ]
   ngrid length 1 ge {
      [ngrid 0 get]
   } {
      [24]
   } ifelse
   newanneau
   gere_pstricks_opt
} def


/pst-prisme {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base decal rollparray
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   solidhollow {
      dup creusesolid
   } if
   gere_pstricks_opt
} def

/pst-prismecreux {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   dup creusesolid
   gere_pstricks_opt
} def

/pst-grille {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   newgrille
   gere_pstricks_opt
} def

%% syntaxe : array N h u newruban -> solid d axe (O, u),
/pst-ruban {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   h axe 
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newruban
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottesphere {
   % rayon
   % mode
   % r phi theta option newcalottesphere
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newcalottespherecreuse
   } {
      newcalottesphere
   } ifelse
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottespherecreuse {
   % rayon
   % mode
   % r phi theta option newcalottespherecreuse
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcalottespherecreuse
   gere_pstricks_opt
} def

/pointtest{2 2 2} def

/pst-face {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   solidbiface {
      newbiface
   } {
      newmonoface 
   } ifelse
   gere_pstricks_opt
} def

/pst-Surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   {f} newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-Surface* {
   r
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   {f} newsurface*
   solidbiface { dup videsolid } if
   gere_pstricks_opt
} def

/pst-surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   { function cvx exec } newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-polygoneregulier {
   r ngrid 0 get
   newpolreg
   solidbiface {
   } {
      dup 1 solidrmface
   } ifelse
   gere_pstricks_opt
} def

/pst-fusion {
1 dict begin
   /activationgestioncouleurs false def
   /n base length def
   base aload pop n 1 sub {solidfuz} repeat
   gere_pstricks_opt
end
} def

/pst-new {
   sommets faces
   generesolid
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-courbe {
   solidlinewidth setlinewidth
   r 0 eq {
      range aload pop function cvx [resolution] newcourbe
      gere_pstricks_opt
   } {
      range aload pop function r
      ngrid length 2 lt {
         [300 4]
      } {
         ngrid
      } ifelse
      newtube
      gere_pstricks_opt %% r function [36 12] newtube
   } ifelse
} def
%
/pst-surfaceparametree {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurfaceparametree
   dup videsolid
   gere_pstricks_opt
   tx@Dict /function undef
} def
%
/pst-surface* {
   r
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurface*
   dup videsolid
   gere_pstricks_opt
} def

/pst-vecteur {
gsave
   /activationgestioncouleurs false def
   /vecteur_en_c@urs true def
   solidlinewidth setlinewidth
   2 setlinejoin
   1 setlinecap
   linecolor
   linestyle
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
   args definition cvx exec newvecteur
   dup
   gsave
      [linecolor currentrgbcolor] ( ) astr2str (setrgbcolor) append 
      outputcolors
   grestore
   gere_pstricks_opt
grestore
} def

%/pst-vect- {} def
%/pst-vect-2points {vecteur3d} def
/pst-line {
   gsave
      solidlinewidth setlinewidth
      linestyle 
      linecolor
      [args] ligne3d
   grestore
} def

/pst-objfile {
   solidfilename newobjfile
   gere_pstricks_opt
} def

/pst-offfile {
   solidfilename newofffile
   gere_pstricks_opt
} def

/pst-datfile {
   solidfilename readsolidfile
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-plantype {
%   args definition
   args (pst-plan-) definition append cvx exec
   dup phi rotateplan
   base length 4 eq {
      dup base planputrange
   } if
   origin eqpl@n pointeqplan 0 eq {
      dup origin planputorigine
   } if
   ngrid length 0 ne {
      dup ngrid planputngrid
   } if
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def
/pst-plan- {pst-plan-plantype} def

%x0 y0 z0 [normalvect] norm2plan
/pst-plan-plantype {
   dup plan2eq /eqpl@n exch def
   /plan-@k true def
} def

/pst-plan {
%   args definition
   args (pst-plan-) definition append cvx exec
   /pl@n-en-cours true def
   definition length 0 ne {
%   plan-@k not {
      dup
      base 0 get base 1 get lt
      base 2 get base 3 get lt and {
         base
      } {
         [-3 3 -2 2] %pop base %aload pop boum
      } ifelse
      planputrange
      origin eqpl@n pointeqplan 0 eq {
         dup origin planputorigine
      } if
      CX isreal
      CX 0 eq and
      CY isreal and
      CY 0 eq and
      CZ isreal and
      CZ 0 eq and not {
         dup CX CY CZ planputorigine
      } if
      /CX 0. def
      /CY 0. def
      /CZ 0. def
      ngrid length 0 ne {
         dup ngrid planputngrid
      } if
   } if
%   dup RotX RotY RotZ rotateOplan
   dup phi rotateplan
   /l@pl@n exch def
   tx@Dict /solidname known {
      l@pl@n solidname cvlit exch bind def
      /solidname solidname (_s) append store
   } if
   l@pl@n newplan
   gere_pstricks_opt
   /pl@n-en-cours false def
%   action ==
%   noir
   l@pl@n RotX RotY RotZ rotateOplan
%   l@pl@n CX CY CZ plantranslate
%   fontsize setfontsize
%   setTimes
   1 gere_pstfont
   solidplanmarks {l@pl@n projectionsifacevisible planmarks} if
   solidplangrid {linecolor l@pl@n projectionsifacevisible planquadrillage} if
   solidshowbase {l@pl@n projectionsifacevisible planshowbase} if
   solidshowbase3d {l@pl@n projectionsifacevisible planshowbase3d} if
} def


/pst-plan-normalpoint {
   /plan-@k false def
   norm2plan
   dup plan2eq /eqpl@n exch def
} def

/pst-plan-equation {
   /plan-@k false def
   dup isarray {
      dup /eqpl@n exch def
   } {
      2 copy pop /eqpl@n exch def
   } ifelse
   eq2plan 
} def

/pst-plan-solidface {
   /plan-@k false def
   solidface2plan
   CX isreal
   CX 0 eq and
   CY isreal and
   CY 0 eq and
   CZ isreal and
   CZ 0 eq and not {
      dup CX CY CZ planputorigine
   } if
   
%   dup plangetrange aload pop boum
%   dup origin planputorigine
   dup plan2eq /eqpl@n exch def
} def

/pst-geode {
   ngrid aload pop newgeode
   gere_pstricks_opt
} def

/pst-load {
   solidloadname 
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-point {
gsave
   linecolor 
   1 gere_pstfont
   action (none) eqstring not {
      args definition cvx exec point3d 
   } if
   texte args definition cvx exec pos (text3d) append cvx exec
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
grestore
} def

%% syntaxe : alpha beta r h newpie --> solid
/pst-pie {
   phi theta r h 
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } if
   newpie
   gere_pstricks_opt
} def

/pst-trigospherique {
3 dict begin
gsave
   solidlinewidth setlinewidth
   linecolor
   linestyle
   args definition cvx exec
grestore
end
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         procedures pour \psProjection              %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/gere_pstricks_proj_opt {
      /planprojpst where {
         pop
         planprojpst projectionsifacevisible projpath
%        /planprojpst where pop /planprojpst undef
      } {
         /solidprojname where {
            /solidprojname get noface phi  
            xorigine 0 eq
            yorigine 0 eq and
            zorigine 0 eq and 
            xorigine isinteger not and
            yorigine isinteger not and
            yorigine isinteger not and {
            } {
               [xorigine yorigine zorigine] (                 ) astr2str 
            } ifelse
            projectionsifacevisible solidprojpath
         } {
            xorigine yorigine zorigine [ normale ] projectionsifacevisible planprojpath
         } ifelse
      } ifelse
} def

/proj-pst-chemin {
   solidlinewidth setlinewidth
   1 dict begin
   newpath
      /cercle {cercle_} def
      path
      linecolor
      gere_pstricks_proj_opt
   end
} def

/proj-pst-courbeR2 {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop { function cvx exec } CourbeR2_
      gere_pstricks_proj_opt
} def

/proj-pst-courbe {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop {} { function cvx exec } Courbeparam_
      gere_pstricks_proj_opt
} def

/proj-pst-point {
   [proj-args] length 0 eq {
      xorigine yorigine /proj-args defpoint
   } if
   /projname where {
      pop
      [proj-args proj-definition cvx exec]
      dup 0 getp projname cvlit defpoint
      dup length 2 gt {
         1 getp projname (0) append cvlit defpoint
      } if
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      solidlinewidth setlinewidth
      linecolor
      [proj-args proj-definition cvx exec] 0 getp point_
      gere_pstricks_proj_opt
      Stroke
   } if
%   1 1 0 0 1 1 Diamond
   texte length 0 gt {
      proj-fontsize setfontsize
      %setTimes 
      solidlinewidth setlinewidth
      newpath
      linecolor
      texte [proj-args proj-definition cvx exec 0 0 phi neg rotatepoint] 0 getp 
      pos (text_) append cvx exec
%%    /planprojpst where {
%%       planprojpst dupplan dup phi rotateplan /planprojpst exch def
%%       pop
%%       xorigine yorigine
%%       0 0 phi neg rotatepoint
%%    } {
%%       0 0
%%    } ifelse
      %gere_pstricks_proj_opt
      planprojpst dupplan dup phi rotateplan projectionsifacevisible projpath
      Fill
   } if
} def

/proj-pst-vecteur {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      xorigine yorigine 2 copy proj-args proj-definition cvx exec addv drawvecteur
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defpoint
      /projname where pop /projname undef
   } if
} def

/proj-pst-droite {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan smoveto
%% 	 planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec droite
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defdroite
      /projname where pop /projname undef
   } if
} def

/proj-pst-polygone {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
      newpath
         xmin ymin l@pl@n pointplan smoveto
         xmin ymax l@pl@n pointplan slineto
         xmax ymax l@pl@n pointplan slineto
         xmax ymin l@pl@n pointplan slineto
         xmin ymin l@pl@n pointplan slineto
	 planprojpst projpath
      clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec polygone_
      planprojpst projectionsifacevisible projpath
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-cercle {
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defcercle
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%% 	 planprojpst projpath
%%       clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      newpath
      range aload pop proj-args
      proj-definition cvx exec Cercle_
      planprojpst projectionsifacevisible projpath
   } if
} def

/proj-pst-line {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%%          planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec ligne
      eprojscene
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-rightangle {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec angledroit
      eprojscene
   } if
} def

/proj-pst-texte {
2 dict begin
   proj-fontsize setfontsize
   %setTimes
   1 gere_pstfont
   solidlinewidth setlinewidth
   newpath
   linecolor
   texte 
   /planprojpst where {
      planprojpst dupplan dup phi rotateplan /planprojpst exch def
      pop
      xorigine yorigine
      0 0 phi neg rotatepoint
   } {
      0 0
   } ifelse
   pos (text_) append cvx exec
   gere_pstricks_proj_opt
Fill
end
} def

% END solides.pro

%%EndProcSet
%%BeginProcSet: cm-super-t1.enc 0 0
% This file is generated from `T1uni.map' and `glyphlist.txt', `gl-other.txt'
%
% LIGKERN hyphen hyphen =: endash ; endash hyphen =: emdash ;
% LIGKERN quoteleft quoteleft =: quotedblleft ;
% LIGKERN quoteright quoteright =: quotedblright ;
% LIGKERN comma comma =: quotedblbase ; less less =: guillemotleft ;
% LIGKERN greater greater =: guillemotright ;
% LIGKERN f f =: ff ; f i =: fi ; f l =: fl ; ff i =: ffi ; ff l =: ffl ;
%
% LIGKERN space {} * ; * {} space ; zero {} * ; * {} zero ;
% LIGKERN one {} * ; * {} one ; two {} * ; * {} two ;
% LIGKERN three {} * ; * {} three ; four {} * ; * {} four ;
% LIGKERN five {} * ; * {} five ; six {} * ; * {} six ;
% LIGKERN seven {} * ; * {} seven ; eight {} * ; * {} eight ;
% LIGKERN nine {} * ; * {} nine ;
%
/T1Encoding [
% 0x00
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
% 0x10
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/afii61664
/perthousandzero % PERTHOUSAND ZERO
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
% 0x20
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
% 0x30
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
% 0x40
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
% 0x50
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
% 0x60
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
% 0x70
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt % HANGING HYPHEN
% 0x80
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
% 0x90
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcommaaccent
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
% 0xA0
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
% 0xB0
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcommaaccent
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
% 0xC0
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
% 0xD0
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/SS % Germandbls
% 0xE0
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
% 0xF0
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls % or /germandbls.alt
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMMI10
%!PS-AdobeFont-1.0: CMMI10 003.002
%%Title: CMMI10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMMI10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMMI10 known{/CMMI10 findfont dup/UniqueID known{dup
/UniqueID get 5087385 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMMI10 def
/FontBBox {-32 -250 1048 750 }readonly def
/PaintType 0 def
/FontInfo 10 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMMI10.) readonly def
/FullName (CMMI10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/ascent 750 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 120 /x put
dup 121 /y put
dup 122 /z put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3C05EF98F858322DCEA45E0874C5
45D25FE192539D9CDA4BAA46D9C431465E6ABF4E4271F89EDED7F37BE4B31FB4
7934F62D1F46E8671F6290D6FFF601D4937BF71C22D60FB800A15796421E3AA7
72C500501D8B10C0093F6467C553250F7C27B2C3D893772614A846374A85BC4E
BEC0B0A89C4C161C3956ECE25274B962C854E535F418279FE26D8F83E38C5C89
974E9A224B3CBEF90A9277AF10E0C7CAC8DC11C41DC18B814A7682E5F0248674
11453BC81C443407AF41AF8A831A85A700CFC65E2181BCBFBC7878DFBD546AC2
1EF6CC527FEEA044B7C8E686367E920F575AD585387358FFF41BCB212922791C
7B0BD3BED7C6D8F3D9D52D0F181CD4D164E75851D04F64309D810A0DEA1E257B
0D7633CEFE93FEF9D2FB7901453A46F8ACA007358D904E0189AE7B7221545085
EDD3D5A3CEACD6023861F13C8A345A68115425E94B8FDCCEC1255454EC3E7A37
404F6C00A3BCCF851B929D4FE66B6D8FD1C0C80130541609759F18EF07BCD133
78CBC4A0D8A796A2574260C6A952CA73D9EB5C28356F5C90D1A59DC788762BFF
A1B6F0614958D09751C0DB2309406F6B4489125B31C5DD365B2F140CB5E42CEE
88BE11C7176E6BBC90D24E40956279FBDC9D89A6C4A1F4D27EC57F496602FBC4
C854143903A53EF1188D117C49F8B6F2498B4698C25F2C5E8D8BD833206F88FC
BD5B495EB993A26B6055BD0BBA2B3DDFD462C39E022D4A1760C845EA448DED88
98C44BAAB85CD0423E00154C4741240EB3A2290B67144A4C80C88BE3D59AD760
E553DAC4E8BA00B06398B1D0DFE96FB89449D4AE18CE8B27AFE75D2B84EFDB44
143FD887F8FB364D000651912E40B0BAEDDA5AD57A3BC0E411E1AD908C77DCE3
981985F98E258A9BB3A1B845FC4A21BCC54559E51BC0E6C22F0C38540F8C9490
88A0E23EA504FA79F8960CC9D58611C519D3ACDC63FB2FBCAE6674357D7F2285
4BCC9F54D3DA421D744D3A341DA3B494BB526C0734E1A8FC71501745399F7683
FD17EC3044419A88C3979FD2ABA5B0130907B145A8462AAF0A9B511D2C8A7C7F
347FF6AC057E6512902BFD2918E2CD31DE615F5D643764E900B60287670AE18F
FDE15545D8BC69591A8CBBB275AFFC9B14BD68DF0AAB32268FB84844D4DBC7BB
C591C1AC5102C50A9C7BAAA848DA88B0519F0F5F0813BF055CF0E3C86F633A04
B779D2E8E656DB1E09A66A85FE21CA8BA5523F472A229E83F2C4E91ABA46C733
F3C7B5775B06C97782BC225C46385BEBDC61572458EFC5CF4190AB7A9C1C92DA
29F84BAACF552089195966E3AD9E57CC914D20B6962BE80429A16D4DF1ECAA66
36C4343FADF0B2B48F12E2EB8443C4AA29D00949255F3968617F98B8ABD4CC12
048B838EE243A21AC808BD295195E4AE9027005F52258BFCA915C8D9AED9A2C0
80814F79CF943FBE3594C530A22A92E11BE80FCEC1684C4F56712D5846B0749C
9B54A979B315222F209DEE72583B03093EC38F7C5B9F9BCB21DBE8EDDAE9BE8B
75ACE6B12A31083AC8348EC84D1D29D2297A266284B7E9734E207DAF59A25F4E
4AA38509E993C5394FED76E6A2F25462685C4C86C6E8CFC9863338EC1428BDFC
74616BB1BC8948B0ED4C87C15B4405F3A7796F9DB3798FFFE8BD0A94E834817B
D5E9812E308D0CC920470A6F2CD088FCB80462BF7CB3F039A7DF3DAF5B2B5355
E083A385CD2EAF0FC181E40E96DD7E9AB9EF5C7E6866A13B8A54718E950FE097
EF0951A357114F18CE9933D28B3A77AA71E3CE884661F13284BCED5D5FD1A86D
543E588FF473DC2CF9A4DC312500135F29C2D0174B32018C8DBD40EF9A232883
710A1F2AB2CD11312300ACDF789A9B7B93D2035D81D1C84984D92D78A53A00C6
EDA94B24BBAC1AD17774A4E07E6F74ABD90415965616AD540C8ECD8C3A44EE4F
7F4F6BB6238C5062D63FA59B7BF08BE93FAEA70A2AB08FBEAAF7DBF56B95FD93
03CA406543BA6C9527D0DF01F5108D31A51778A5EB1C93F27B72B46146A353A2
01CACBC829603B9989A87CF64528682CCBA0562A8165B185C58A5C6BB72F5E89
500ACCAAB8ECEFBB2640E99EAEEC4EA979AA793D013D61D8ACF8784FF8D9398F
F6A252A709324FB39509F0B3A4E725E82F53543383C6765BE556CC897C758208
AA3AD37B0406E4A79F8F0A6C1983FC73E71CD858C0DB66ED66D5D992978614EE
1EA91EBE191E082EBA1FC040AF19A2202575C2EBEB8058833E3520FA03D2F915
85C1ED337E457B9FEEB0C6EF2735EFDA6E0D05FA641BCF698AC6B97751E8306C
4DF00A39B8581FF53DB8F8525FDB196D85950906CCB59B8EF171349AA3B567B1
6A00819947A995FB383C3C1709C9A2C113B2E40BB832B7D4A0FBA0B16A2C455F
55809CC425C403E9668DC66BE45B71A81C332FD4DB279D22A2959962304A8F18
085893DAC61317D24A8F198FDAB95F3B86F0AFD35047B868A9A17037A2829A02
BAB042F75F349E197A7EED41984C2859754CAFD0251439921C248B463B516951
2E1322C80D73F9CBCAA63A585450275AC2492E4D3FB78E800F788254DB5E610D
CF788DF5C70FF99892BCDF16133E34B24B77C8F097F546B87C603DDB8998B66E
BACB68BA27462AF54AA405682EC96D701F0D474DECD5F95CA2102DF639EB169E
D518162C2BAE45FF698B6DE15FC6E7DE48C336C40A670FD26952A6BAB09115E1
991F0073419F2CC2A1C08BE91096936AA0C37E4ED3CCCEE235476074B8FF1125
6BDE3701F85532D8BB64CCC927CC335281C95EA689706F0AC717DC2CF680C754
E5EFD7FA4BB8880B2B727A964C876D4A223069D4E6001771F0E23EAD2A4BBC80
E76675297B2EF05F52BF4E71B3EE2BE3048CF088C79540113C66AE98B2FD3CB1
B0741A215FD070882C52765009D7D711DAA2508F19AE7DDA15229A856AC49BC3
4DDF40814FF96500E4B9B02D412E94623C5FDCC76C0FB8E42DF56A904FE49D65
1DA7C53901B2EA71AB658A464D3ABDE27D9DB8D9E0B48F64E61A2495AD5D8DAB
B5E72424AD017DF37964AF911BD7FA21A5EB4775DC8E95EF0C0EB856B00D89D7
8172A1DE8530767D317B8256103E53CFB877E10686A04F5A08F8DC58D843DEBA
FD5F40597588663D103689F6EB3EB14D06E18C8078F2538B43E712DF491FC5C6
AF639256C8C6134B64D560D8476DEA6329D995E46CC4BC78841C59E73648B47E
BFA7DE0846422F738454AE77E822A083405289247BD7C478BE4974F742CD6051
E99FBB1D1B3FBABFEE855174734EE45E87D0AADF32B1283B911162A9955847FD
38944D70584FAA6B1A7191C5C134B73F98EB632B69E2F0C0F94156787C34C8A3
7622A029D58F9626B74F8A8A1F3803E0BC20E0EADEB1E99B70F1BD9F980FB751
2A842843DE42EB142A84D5D3138629AE9EAF6F3479C423E8829C8816FA6EFA27
DCE5580E65AA9854B1C64163DC318420CD993C15BFD76A8BA1182860A6B03D6D
22B8CF43CFE6C8AB27C64842E239CAE707D3086BADDE1D7C94E3BC96319470D6
8D26915C575CFDD03271D6BB9DE86A0EB6EEA6E768B224A626C62A9AB48A6EDB
44F70BB5AF991CDF9736D65933E81CC57A78F623F33EC9AF535F2F25FA4EEC90
D50DB7E87F31E971A75A33A301CA6013EEC5A4E179D695B33DADF2C98364434A
42926776000B610E17524162253F6FA638D6581C18F99EA0BD1D2E24D2424ADF
C05010D08192485153DD03930C7BF45237593E484F9851E6D464FA10FECA5D9E
0C8CCC97DE029030900CDBB491C5CF226DBF903CFE7735D939C3FDF3A20B70CE
66579B28B99313FEE914E295388C7BC8E055A2E54EA3A8206D3C8F4F7C0BA5E6
E519419FD8CE215F7B8E9BEC604A9E3FE272A0328A24E31997C8A91E0946BCF1
6943A97CBED2AB9FC636B49828BBB8B89E0BBC2653796431224895ABA5DAC41E
1854BD9764E86147FD7624F736F40DE3B7582EDDFD15C2BDE3F22B5A54D7DF10
B87A1301CE85CFC061689A890A321412A13314AE96DCD3EDA75035FDD8F4AB9B
897A2C68263A68457032C469987970648BA2D88B1C5375DFEAA35A917B8A952E
EE670427942AEDB3CB599C5746180E392837D371E15D860620ABDB6AA7772C40
A5E346661673ACA530BE3D8E3FFB895E5DA3DC23B1B43C080C77F7E47847F0F3
F3AA5CA9E4BF75FC5EBD18D19F21A7DAA3B11CABC6E4070A15F7DBC8B05EB6AA
A02EF1B078EB66D61D6AFE41DA9B36FE7EC9EF94D1EA26282A9871E2CACB3126
2AD49C2D9B50A6E47D8F2CCAD50992D1B430979A45FD9E76182A19964BB2A1F6
51779A2B258DC1DF4C2F3074621286831F3848AC152DDD2BA561E6586ADA88D3
598A2CE2CD048F027CE0008B828BD915887D7785341E8305DF2346ADB76BE99F
87B02173BDC334E9221C8DF54114A6B24C1C5340299512FA6C8C51AB4C8778CE
178CEF531C6D1B5FF0A1BE8EFF767F959BD4C345C52699A29A17B2A230842BF6
4B011217D6D24EDAC3F6D53482786F1CA33169B90ECD499407D37CE9B70DDF78
7B7547B32952535BA9ACD1E244447AE3FCED3AF28717083CF9590A09780984D6
AF0743C82AE4FB3E2BB2856A4153A3967A023FFC35382D6C22D84A924900B6A6
3DDD400E6D2418DA6C27F2FA34C075C902B89EBAE658B3C9A18EEE449DA5A379
337DE95CB7AB3F0970CF1A5D8FAD8090E495570FDFB2FBBA79244780D8035547
C5A55BB21A2270F724BF5D442CDC5BB9F09BE0CAE59B1C2270F0BDACE698F2C5
DE8F66BFB9634904B161F5BA2B1950048300D69BABD312D58D89C4ED527AF7BA
7DA2478EDC2CDEE3473DD8A8ED9D891CD1FC21F23013228BB3281B71FCE959BD
6F8E9059D682A7FCC5265A0620992D4FA8D78377EB34CE3ECA070EE3707239BC
98907DB0120CE42ABA32CF97127E28382BDDFD685674279F588D4F951216C355
821361790F64C2CC720DE97E8ECB57326C43EE47367628E05769E106868B54F4
C33C9951908DF6FC4F5ED2C7787BD8FA591BBB3E9C6C1DA94CC5E38D9B20C886
7D237572FF46DD896A4D6163408EA6CEFAC398EE041EAE29D577E75326CA17A6
B072D47A7B13EC441CE6DAA042ECD02134CBFA6809A435050413817193DAEB16
A5882C8AEA44BCF36E74E9ECCDFE7E19FF5A5DD7A94E5AB4F8702C3DA7F42325
23C808670A0490F5B373DADE40814FF9650241D3D69C91FBC5ECE728F827D9BF
C928602E05477903449E079164CA39859C4BCA60C579F490AA455F82B5050BB3
969AFB478E0D4A257B3356EA3CD62051FCE6C6B1929CFF85BFDF166BEF658E10
3A55E007F38EBBB248B3F0B8ED1925106B499B762E45113AE1AC9DE09644C84B
9C08034B297314EE69BC32DB6E7D7FB9913CE5AC17E7335979E9DCCE2BAB3725
1976155551F9706A576FE0E3ADCCF72C87683291528ECB749CB0ED291966E239
B5E3630676BD409E08F85BC1AEC9A2D4135376284A96EA24431243BD6FE8B966
95F11A4BB53F392E0AEFEA623064FF8A7002367B0A515635CB2D2DDFB9B4A8D7
FE721754E81BBA548848A235B91AD4E4F7DB19CCE2F61D277FC00AB956EB93BE
44AB4970CA56BF59506C94ED160FB1E25D3DF2988A532BDB787BFB8539D22986
FDC378AC31444E63C4727FEE121A43751043849E6DCAC5B59D0FC703AAFBBFD4
E8B7C268F21615AD02CE9DABEFA27B5FE6A6441B619539CAB1F810F1263447AA
633F5DAF483752EF1A0421740E3A811D2D2898CBF53E7F686C9223FD7235F02D
6F90D2D48CC20AB87778DE3C6FB335E0F0EC20B5DC5B65223FE117526DE2C72F
FE839DF93CB2A7D66CD900CB325F891E311BEC932F703FB4FEFA29DB8B9C88DD
375EC71B3D58C7BC59ADA91971A3BDA1ADEA629CE6CC92BD542CDDFAA7706FB2
6CDDE2DF07E56D6741916AE8E8744339816F3E6C38062747AA9FDA2A2678A6B7
EFEA870AA3A4D71B25EE3013EAB1DBA34401B867C7A41AE51E0421D41D3BB83C
E120C8FEABA6E5DEC53A689C21426D4BBCB68CB37568761C360E6D4E3596FB7D
F4DEC7918E58C0293D12D6DDA7E9DCDAAD7C939F55CD1BC4A228B31E9A904156
DA6B40B08E6ACE674618B768DD681C772A3E55FE096CF949CF3B0460ABDCD891
D17B37B355B29AB5137899C036F31DA026244FA25FB798FBE5105BDA29F46538
D3D3AC1001A7BCECE64DE94FFE6C354166A0F97256137BDFA07F6E22A3D1D2F4
9588DBAE95E895BC5E64DDCBBAA8D0A22C229B42CB717FC711E7E9DF793DF80B
9F14754585A3C7E17F37B32924B9F9870DA8635E3E18BD1DCD81EDF01834D9C6
B33F23C956C2FCBFA47D84422F583459D827D1E120B97694D12F1F54D02379C0
D288F7104F3FFCF4F76E3494F4ACBD1BE3A15543CC680924C78A473F8E311ADF
8FE00A04C6C393DE61AD3EDA5BC031E2353076A2489391B52632387CA28A7B93
FBB065A6EF3658AE80B1ADA47E9B2539E73A71FA75645F85ED8ECC257FB4CF26
B6C912DE9D0F9899E70BECCB934AD32CF49A093371A9F73DE6255EBC39DE1E7F
00D0CBDABD4D0383977E694890E71FBE5C376BE5F3A80C28987417504F515C50
909F3D31178BB9B1D085BE514F71B910A9085BD6122DDC72A150BFE266920E49
5661BCB4BAB51D6DEFE32B616963DBD989FCDD1637B294CE4E288655FBEFA1BF
7F25BBF8CF17C2D5FD161A7C2CC9CC7490D9BF15A1D35B3BFA43ADE256E88BDA
BD490D92907C57BAC408A575EC84D6AEE070148C7C9A91C03B09FDBD792E8FF0
C0B886AAD2EDD86541E5E579359D40E3AC312ACD3D8FD49F71BD533DDF8859B1
BAF17F1884E331DD07CEEF93B71D492AEBAADF7A263450A7A72210CE630A0D37
BF024BDC09ACC882816B8C22C62AE38A3A8D0F6EBC2B1B2C0B8161A8B076DD5D
4B779C0788546BB4CF57332230D237856B00D79C28A7C01D11F44B7304F69075
94B97A745DA43D1BE561372CE611C345A843834E46AD9DDB16CABCD3FA33D6F1
F6B5C0497F5EE5400B305CDC16A7EC286AA4D45D0EEBB9DA06AC9C5294D68EC9
E4DC3CA2B92CE8FC0526184A86EDC7AB34D67E60AC12D9CA8FD300235EC968BA
92C6FBDA47572BC5600F25249F60AD287CBDAE980E747FCBE7EE5CD323E733F0
63553B494D3DDEB9CC1480B5C3BB79A28E419AA65B18CB297AB383419E890E2A
CE6F98C9900CCB4675280A10CF060B8D220DDA1BE55DFA65715EABCC1AFAA271
B1F8732341613E17B231231A0D24D4D7FC198AE04D89A99C4536217769C6FBD9
5EE24A6302F97438F7C0E311C878F674B4477A5ADA3952CDE4055AC408B8174E
86F8FB797646DFFFE0ECA25D1BAB9A9F71F3926D3D85AA63E7A8C931D71E79E0
AF1EAC26FADE468F4FF7F3861D14C10E3BE1F9EAFD6D3A544E8108D5DAB5B180
3950C74818BC8AF4758A108F462EF1826647A49667F5E482038C54716856D9BC
35F29922846D2148F92F943E951D7438C73D6A60459A8003174036C64E1629CD
155D47FD04B03C023AD67CD5A70C98AB556EEAB8C48169706E5B352F6505D580
AC945171BFE62E81F8F500438AC3B64D857BA5BC54C2C4BBB237F8FA51296255
E66A92A61FE13FDE781D393557EB72CEBAD86511035F775FAC39A0479CCD400F
226709118F887F47CC2ECC8F79816D4A945B2845F50AFD62D8C9A9BBF4739496
9E644BC9F7B04803B7EE75A09EAE94365F6F374B4FCEB0B506C76297564B9B6B
8B812BC3A33929AA94692572B010E6210AEAA312BDFC88BF302244AB9D587A9B
919823FD01DE12438D960944D1977800FEB49E638C32E5B188B1CA033E0C37EE
A142F746367888AA119535F0CCAF7EAA461B790EB089D2D6962E28A398439BB7
9C9943654D7A2D765B46BC0DD1F915327F369162E1BA1BA83110B93F442905E0
523BFF5E279508A98568CD5CFD18FABBE9D17265A9081E7BF64155A2CE3C0DF7
88D00671AD65654709589BAD7EA65BBA811387ABA5CA0BC3F66D3D48597A0D1D
2C268375DF47CCF62166262AE4840AB03BF49BE67A05EF66328EC729F03CA5FF
AD3937FC053E223303565DC771ACF32E63DFB96D5030E787961D72D02C195C66
B48E9AF0309DC169CFE8D16E2818DA94693A18F027DEA0D91051800EE6C54285
AB0594D87D05EB4CB44FFC094DA0072AE7D4BF2F4F9BB812FED256B937BC2574
8C529F97ABA6DAD956BFFC367448EB7FE9D1975B82DF29D520370354429740FD
C55226BF63CA700BBB868F713AE6B4B891BF47CC2EAF14877F5FC21C72AE41F4
BEF155B28ACF0458F6D0913972E771285FA368EF7CD55F0E5E3B2B5BC4C9E8A7
CAC89667C966C7A0517B909E752ED2A2CD604BDCE93D2247D5A603D163CAA250
AEBF479535C34E5063E67207C507454F2A76A45B776B4B3C9916D9E8C94EC2FB
ABAE3552F71CE1FFE48C00554707A2604897546FDFBBE0F36410A80C6ED763BD
FE16CAD8A4692FC306F233975885DD6FA5DEEC88203E9221F67484DD83BDA8B1
09E906D0F26B9A904F60972705AB65BC5AFD9F9E350380FCB4B0276A0524535A
489B8F4E1ACA2ECBBA8EED513EFCC0E61882E371793A223DBBD5CFB45E4BBFB3
9D76E3373F09A57CB319998018CA7F1668CB52A00D2A330B3C0148E8CEE1746A
8BACFEB7CD75153978B12F6C833C529DAC0B63B24331CC999DA586BA10EAD9BF
226E611343378B8EE055FEFB398CF5A5215BC258199F98E594D65CAAF1DE621D
E4238BAFDE59DBC4AB69ADC77FB529BD2B1651BCF681AABE01A9189B4AC46955
DC0E8776A4C401B26E9253B2C5A07B4FC5CC72C9446AB884E2A350DE6F15EFAF
FB8F8510E2111E626F610EF1CC6911CFFAA0BFC434427B24FADC2B17906D07A1
FD6C56353A1F380F0DA2E05572DF4AFB3E28EC60E246D67A7ACD60B40ACA4D5B
5E7EABC6F39FAF23733D26E39CB1C7570338EF118DC382765090D6186886838A
9D1CD12830A595C27E93518B2E8DA5FAB0BE98975FC904616C05847C2F4A6836
319BAA06093DAD6DC72F947D4881E671220AC0DC04A8CE0DAA2C226030231690
AA1FCAC639911ED82336AC8F20AA5B3139D2E9F427B4ABD6F75964E494D79A5C
5D8D57C6E5BE66B0FF7B1AFA5DFB1E5D47A794303BADA2DA1D6E6BB5A5387F6A
FA7A5759A7C28A47E311C3769B5540215849F146C3466AF12B106F2476AFD38C
8C9AB214D0509089311B5D156D95730263D499ECB79D31BFAA80C64686F2C3DD
38AB1A4BA1D580785EFB26D4971EAEA6B8962EEEB18C028E667FE28460E92BFC
91FB7828FEAF29CEFC8E1983
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: SFRM1000
%!FontType1-1.0: SFRM1000 0.3
%%CreationDate: Wed Sep 12 2001
% Copyright (c) 2001 Vladimir Volovich <vvv@vsu.ru>.
% See the file COPYING (GNU General Public License) for license conditions.
% Converted from METAFONT EC/TC and LH fonts:
% ecrm1000, tcrm1000, larm1000, lbrm1000, lcrm1000, rxrm1000.
11 dict begin
/FontInfo 6 dict dup begin
/version (0.3) def
/FullName (Computer Modern Roman) def
/FamilyName (Computer Modern) def
/ItalicAngle 0 def
/isFixedPitch false def
/Weight (Medium) def
end readonly def
/FontName /SFRM1000 def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox{-189 -321 1456 937}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052BD0CE60552BD63101D7CDBEEF5B11
69C468645FE4ED1AF2541AA0770C1DCF81623DE0ECDF49F2B522618F650CE6CB
CC8C21885DD61AF8A523AA677EAEDDFA51A1F9B1885EEE0456196D634E04EF89
F17499DAD982502ACC349B9EEAAE4A71A73D1147318C60A8BAC10510DE90D8D3
F46E47295D27129A5AFE0C65E22BAD10D06885A2EE623FF8E1D90287A083E00C
EF25195F68A2A98170E48759F267FE330B57DF626EBF73D2779A4A6B462AE6E5
19E5878939A488F2FE1094A76925CD24DAD4573AD3CF34E426708CF06E7EBFFC
BEF5595408106E2189F418D17AD510ED5B6A528E8902AA3A5F0FF52AE3DEAB07
32F06B63E28BB88229E046F4FF8A356BBDDE82DF2A197F2E26CA00D5594725A1
83A89A36487EAAE1AC312C929CDCE50722FA6C596C261E4D78D6C6ABF77F5CCE
0E410ED74287A0F201140F8D9674A7AC585D3CBC72CCB824F9E1CEBD08AEDB3A
A4015CADF471F7ABD9B0F0AF73A8274FD441BC1988A61799856E4770155341D6
516CD0E25BFA59B67AB7E0571DF3F5BA70AB52137D9E6A79EFADBE70CA05AC8D
991D0895C8FFC747FBC0E9A7212BAE6560B9E2B64FFCC58112E64A3B4CF7ECF7
595F51C34AD1342F5678FE1E62EC5A389CF04E82B5F832914B91F921F30A7E32
CA3919F57A2D9DE844CAAAC0DC751C255C9916595E8C9532E7A0A84A0AEFCACD
83EDE059FD06EEE9951473180B517F25F609F347DBA012AE9F004DC3C771777B
BE812787C3C50315D67254A384EB65F260943C6E16B2CDC64E15EEEDC67C5544
8ADE9981A6867405E46222CACCEF79F9DC8674268BBBE1EFEC2187A75FB7FBF8
CB2DB2134848DEA2F9CED443DCF561E7272B38F830871B2A5196A787924EF556
4B7E9093ADD414ACBC10147944D216D35003A04FBAAE3B24CE5E678ED3999320
7EFE54927511F03B92E87A055D27E006A2981731AFD80889663DB01695456845
3F095FBD8D2C6FF35AD5F21FAE46CBBBA6C32980D1990823C01E2F52BF077E67
99589E81900487A2273EAC0824A354D97423C814D951066D083A64DDE6524952
F356B4399BADC5BCF4C85CCF00AE7E5AE7C7FB7E45977F7DA14915258EC7C7E3
2DB1DA8B9BB3C2E69ED8A267500638CAAE75F8F6954E412C3E88ED708CC47EEB
701A6D026C56A4B495AC3E1E883C56A1D8AF76865138859A8194514795031C28
83E274A3C1207D5DA20797DD4E14A49792B406531B0A607197A0BEF6433D515D
585A3F9321558D70B55472D03CED9482E4D1F69DBE7C905652CFF5DDB768507D
A2CF9AB31CFF42FE6B4CF0194B96C0C0446D212BEF4ABC1A7FF32AD122D14B6D
6CA60B1F2A6798356799E3D77D4B79CDE5D5B1E4B9CD9158D755D07BEE605425
018F09B4F0347B27755E91448C1DA4991238045B88F44FE2170614953FE8CC41
64BC3652475F29A5573CDD5CDD343E4656DE4DCB47A5E47E0FD4AC99C25408BE
D02EB7D6B01CB47BCDCEB5FC39191954A6EEE713D22A147E3E459165A56D9D69
8D21A020F6254C627A1A104BDE9C760AA0D0182733943B6F21D396C7DC4119A5
B5A8D6B144C84A2FFD5C4A85D99C72701AE41D3E11315D0D6502FCA229C74A98
359A4DE63DE27550A674ED116BE6596675E558F1E4CA70E9A40873FAF826D918
2842260AB1E11B361B15FE09B656F64411D6C17243AC491292EF63CFACECFC9B
A32D69FF8DBEA5BFEDCE2C5C610FB2D6483D01F9E29D6F1DE7DAB9D659D26BB2
11E531663E230D0A9A6F5833E1D0BF99B2A5E5052433CCDCC16AA2A8CB2FB58A
5EC96C7E879EB79905E1DC98C50D8AC0DB4A38933A4D0B8502A3439971EA057E
F95BE3B02988BDF034713D40FE3CA91580AA8445848DC244DCD2C328ED579178
EF58C011564A36E96025BE437B955E06F03D1EBEF2C076AB62355A4DA0E171C4
C809EF91D44B433185E342F01870AF1AE278330DBEFE8C3E172C0FEC80FAB861
171CDE760CD2A66E9B6609A2A16D9EB73F6EEB2ECAADF1C109B50967CB83153C
C8FCE4BC42F2896A43F9E5B34804C604E50B3D261DED65833D96C879674E791E
48A5906BEFA5B5D6BCCA58A41A9D19821CC1047193BD7A2C0C68A2BD3F2D4158
696DDAB1F46D02E2D342E5938EA9E8A9EDE296BB82026DC6A0B01EFE4BD5DEB8
836CCD01222A5CEB4FED271FB4DC80CB99E7BB26F825F8A3708B568CD94AE6E3
2CC9A1DB8EBE55ABDB3D4E09F2FC0B379F3A8A84E3BB231F9B2C9C4814E4022E
B4D8931BE501B80227AF346863851C063848EE420DF02CBC20CAB1782C9F2223
3FBC432C61A6C420A691B81B757EDEE8AC1827B2CE9FE8FCC568F4015335840B
444056B4C9CDF8D31925F75423B83CA6DC6907F3A697683ECBD5FDAA0DB3B168
198AD580430A54AAB1C09C5F14EEF356669E1A56B30B7DFF74395F4C1992330F
B703BB1C41E83EF250DAC865648A2AB8DC7CADC27273EC391D38CFA3A16CBA63
4D6317061EBD4C83EEFB702BC21B3F12A88DD8305E833A817407FD95AC2E7A3E
03D9975F6660D9AB5E2F3E3B148DBBBE4D1D60A3CA285454D7846C8110340C2B
BBD50F0541F1E48A71BC000BEEC2A92135E1705E753E307CC057C8ADC17DE809
C66A71C436D10D890EF79F7FD1FB3D040B5C2FD3922805C21ABCE935E2D2EA56
1C20A2EF10D775443685A08CC91E4F9D187D5EE2D03A7785D88AE6EE26665474
8C6E6F4D3325DCF159B76E583286A811C85C8416CA7B5E0259133A819CF769EC
2C322580AFFD41A9EE2A80D531372163C9574A45888E01A8006AD6CFFC391E51
CA09EDCA5ED3CDED0862E5DB69A102488F32B254FD6C150451948B99CACB3057
3C5E487A84BE0ADB284C3E796FC5664490597DA5F2CAC7C00132D2BC5A15613A
E032CCE548FAB0C8D1CA6FD7F36C8A0F3D67FEECE605A1D09423628B135971E2
5232037B8793DBC5674B6407B78BACA8DB4108DEA628BC51C2D77D99B1CBDE64
D83F8563C0F1CD987D5CCAF9A367930A8015C023B5538245F2CD993523074150
AD1A292F9D0E9A984A2159B03EC1EAB3529CB8F08292E36DC44F9A76AA4668EE
62FCA6F439D937ED8FC073AA840AB74810AEB44D5E4AE05405B64957A8B7E7FC
9F34D3D86AB9ED7C852FBC083108038858FB2FEC41F923737AF59E276B4478FE
E9637DE6D67A6048096FE8DF5442E4C5F08802111FF320EBF1934B101370ABD3
E4AF6708A85CB82ED743B6C59703D80121801D6FCE3BB17ADC8597F9F7887C01
1BD8EC9BA7AF44CC83F1AF7B26E7B4A8BD904920CBF94CA8AA45EFF92E2C875C
0196F8A428CEE1BA1D33170450A1C3EB97EAD7B417106E060E236F64E78BBFC9
156493CAA0667D6EA67095F7E64231ED14C4B259A56AFCC97566939A4CF024C1
D55FEE0F1426459C3997CB2D07E5999E8DB9356BDBB0024CA8B27895075DC972
A1D6E35E5A3E0D58649AC22991D32CB08E341A3D5674D118730F00ED9EE09FEA
4C39D7A98D1263D2DE64BCD8AC45374C54D922F59B13E53525A5C019CF664254
39029A4189E4FC862A31E58DACAF725919D8C00FB81E38C5AC4F7DA679B9BA97
C8A9ACA7AC7A3F8A698BBB490AF8CE6120DC1D4A49FD15D7B593CE662F6DB5FA
DA0C6E56FE7518EC1912CBA9C7B17C38DC89F7448E13DAD954D1140C7F34115C
BE558354CAF340C66FEB9C7F7D0DE177F80E8303D12FEAB7D1BEE3678468B83C
41DD2D29537C7FC74D62C0BA1320D30EE6E45485A6915589105ACE1564C7804B
B55DEA0ADA703FCDA71B2F50D23E951D0A44BDBBEB52CB066DB26D7492A5DCD7
8EB8B13ADDAD8A0F8F052ABD91C424CBD36A884B77EED27D45D8FC743A5714FB
582DDFDB5493F4C6C9C5796BEC270CE7700686FE8B51C3EB481033310249DCE2
08BBD9573C79279D3DBAA71F511865C3017176934072845957CD2F883DCA9FEB
DD996A2DA46A21D5406CBA9E4073B21A8AD49D6127487B375BD31551D5D12BD1
93475E8D6AC3011DA8D2727AB787ADF98A1AEE8FC70A83FC660BE94307919C12
4985C9FCE40F291325A17D6A9527C2A253CBBBB90FE593BDBE5AEE9EFAB7A8E4
6BD8F0A84D7BA6C808523360ED86FF1DB09322F90D66F6E93AE2E85FB09BD17D
CB185D3A00EE1ACEF1C93FEBE1B7B925B17E82024C4583467DB107AE3346AB74
16C3E3E3CBEB057D9DCACC5F70504EEE4A83458AE82D9ED9806A35DACF823E35
8718418F5D842FAF07005B4E8DDBEF263E1949E4DA8521F258E2ED8CE0DED096
3342019ACD976517F49CD5EFB435331F1D522494F12030B1F314B2552F36723F
2FAB3799AC2758F888F3D5320395270872D308E3782FA0F3145E7E684E7C9A61
8A82309AFF1455A0356D825D7A1BFB1B8349019A3AAD25E746791B6AD5BEFEB6
E6B7677647A5F1C7D8579C413CBF21556A5992769A83D5C16287F5E81F0D50E1
42679EB8E48E37988226D1D7ED29EC6E0279EF48C1367EE1021775651CD24D95
46924CCBB0AA25A8F897A5D340C6361BABBC938D5C3572A6F958C306FDB23604
2A6288FE16AA5AA744C61AE97D67897C6759AD87E3797F3A9CCA1B21F6246BA0
12FA35D9B9498269FE4FCB852588C5298471BE647621A7479CE7299AE2614146
5DCB45D1E25DD3551974145029140E8C7336E07F17284C8FD307763A3CE4A6ED
EA771A385282DC5BECF3CA6E2B708E9A1F5F3E455317872B534461F97A4F4A2B
A777FC82B4A73B2627F7E393318AC9F32D30C245DEBA1EEAB80AE8116A65563C
720B8177BA68FB0D443B70D41E9656BFC60CD543C96380CC5FD12E13E9632A5D
47EDFAC59D608AFE9F42F44BA0DBECA87C1EEBBA057227FED5601BB39E849FEE
8536A6C4DA236D422483E9C4F22A844FC65E290D50E2BED3AC7648B4302DFBF8
43070CD1E4926BF659319C3734B81C287C8730A7E3BD3171492D58D252E3FA20
7711C09D47A4AA4094E08CB602B03655E8DB90E845A6272D970CC423D0477175
D39632561D89B66FA78BAABB8CD84CDD725F9AA0BD14891BD1425DED09E8ED41
F97C5013CDF8E22A6889B6A5936B3052952C56DBC24537FE629653120586E42B
A538782002AEB7FDA1A40C43ACC6A5167A044E3EA306028725986806476C3561
7E8C9A08231D2920B26041E3E8F0671D80ADFE316D582C7A94DAF54759104356
3996C4F697C3C73C7799F52E42292F8F328F543E6D4E5F2D535767C1CCA39443
484AC18A3E2DBF09CA2BA555E76957DAF0645376C0B4190D6DC7AFCE1C5C7130
64ADE5E9BAE8DDDEE1EE1EDDB0B6F7DEA4061B3BF0F5E571F6C29BE4D233792C
86AF776D8FF756B5DC4EADC85FA3CF7A5022430286B1A256101389A8A638CDAC
65918A1BC8D00DB6CCE4A875A3C04C371C2F520174C260A04B3BC3A5AC1A65EC
1F8C05EF8DD4ADD68DF705A6A74ACA8AA31889A372F9626FF8A0F31C9682410C
68A8F8286A90170D28C5D533EC873FB16C4CE30DE9213AC81AD06546071A6D85
EBCA5F44252B5C8AF87F8DCA60ADFA539202BDDD3CA40653D3521F5046199F3D
5A6770348B73332A47C7A4312C928A3304A859D98C2AE3B0DF0C136B512B9A02
E94408218A31AC26E444B6BE54A3EB863B4C5BD1695BD593DDB9C8BFC866F7FD
DC952D0E56C971A6BCD0F27FBE6611FCAF53C1123A420967E4913FC00A0894B2
7914F85A2E1611C514D0A1C73129BA8305FCA3D02E59FEA06D99EC8C78B82824
725355BFD4F08A3540248476981DB37BBD08CDFEFE69E8D754E88025BA3FF98A
BC1F58E91F1D66140874153114B81A52D6916406B1866B030AEEDD50B84FFA13
1076BA25EABC30C3605F82B982419207535C12F48EE745C88B61614D26143802
8C8E26A9102AD202B504C7A0DF01F728F1A685854A512F78E04BC5350BE10ADD
76F27CD73DE941821B9892A98E078B3DF000F6D506BED2C7F18217D687D81902
B12D1B449D3D8AD0FB57C79A2BC756B157A590057C76215C21DC2E81CA0828C4
E1518709818929E057650C001FBC2C6B7E13768CB0FFF33452686CB041E672B1
0832FE3ABE66AEBEA33B8D30312048BD8664E7D4D0652D03E8F108B6F6BC35F4
653CBC407A66CFBCB2356D8F77DB1E421B0C9A0F290269D5F9D08DA856287492
A5438EDA0E264A06E99590AB929A12C1C5D7D5C91ED2B9018BEE92F66AAE7DD0
B979E7FB2AE29B0ABE98DF6AA250854DFD65EB4753D13C2A281A87E9AF4E2605
91C18FC29F0DBB160F0EF6716CA4AE79E51AB084E5507764C2F5E80A63621839
743E78CC2850D82D3633C083CB2E4949DC2D2D1ADE17E43F87F57A1BE52F1EFC
FD388B23F459222FC6549561B5EB568FBD90D3A0A3264F70046B44AE9D773944
A2B6234F964715719B27BFBBA02498376F9F3762D6CE21EE6AA1A98C274B59EB
9992695645441232435130296CEAC7B257787522A157A0EF55C49978A94A5D21
CD203E8D13C5DE5A87206BF6C94254D2316E3FC66F259F69A60D949549315DD1
5C4E22656FAD3F9BD0F269C5A081348CE275292485F4A95922F60861D99911E3
3447D9066EC29FDC3D07EB1A5628B5E80FBDF211BE6F1D897029E64779F5D4FB
11CF19C8782C7304E9E1E96AF4D980597E77D486D1535C1D2AE0E13B41733608
F35728C67DE8D3D6926728D6C1D65F381A2A8D1E432A2C5BD3E91ADFC0859512
C893BE2C8473128443F4984CD024EBC4976CD8E9AF1E9B08909DA8BF96CB4FD1
B94C80B3BC32C36588D4CDA171B810471A420552CB9A7A8E6EE0DB0FCE995B26
A1EE18D73BCA1BF6890BF500BE3812229AE3B6EF4F31D113319D95D79BEA46BF
F1AEDE14027B0AED15020072C76103046EDD878C83266BA77FF48BB4064EAEF6
B738D8F82BE60741A3DBDD25B2599B59AE941F922B5D47A2265703123A34BAEE
BB075510D54F9A77851D5DBD8434092F51366B471CA204CD3F2B1FF439949E51
2B2D3011C90ED78F08EEDF876610B22271386A0A8825835FB0DA550DF4F3E5F2
2A007A5F489DB7CBB47A642993047E87BEC2414566492203D8F8FAAB8AA3FE78
ED4CFD67FCBF929AF380C22EE97AA40DF560A9F2D4DF74A8F4E4A8285C1A4247
9754F7AF1CFC91F03AB737400DE056D81DFBF2D17F3E59108C550982497B53F2
787DF1D113F94B000D430635FA0A31BAFC4A4496995A94BC75FDDD1940E2500C
69B21715F5B8AEEAFB7F8644983B8BCF83B5BD48E829C86FDE1AE59F5A0A2796
9C75B1EB9C13A19D55BC8A10A18981330B46E0BA34DC8B7C43DF46169951A878
D7E5C92CC70A2B10D3095B45D701B543ADCF1ABB8D8B737B9C528E4F5670871E
4B60DF77C524FD8584D71035D2F5C5ECAC8E55DE0390A93F94B64458508E6BEC
94FD87729B46EAAE92A24EB5F35AB3303E3312F849BE12E988942E95904C56E1
8EEC593B475F955689CCFDBC9C202D989DD50E2D2A44A78EC43BB7C913B52025
17957983587B8F726547A38CC91E4F9D187D5EE2D03A7785D88FEE73CC63C58D
29AA0A0C38D8C2A0F73A01FEA85A91E195A828CC2CED6271CCFE028C2807F66D
F64C752CBA71B573BAC93A9F5DE147FD141FF208F188012E3D08E568308B1F62
F400D801D7286F6337CEB228F0B38BC6D7D8508BE3A831AC0868B467BF7DF146
4B8EC83E84864CAF98B45C6EA676E3B320DB6583C605038A8FA0AEE394CE8343
6E989BFE4A224A5708922D7B8B21BBB7923735495E2DEE0AD0A6D1415BDCE7BC
1EE0E3D30AC9EA8DAF2A7694864B671B7131A6F795EE8EF47E9AD7B0C263450A
D5B57549CD2235E7A5F16BA0F639D3BE97B7151637D8B1E21E18FE4A3D877B22
1B0727107B7CF39F3C9C7D9912992BEDC93477704F6E8C7C663A83804CABBC70
6A929EBC90C0E77E0EF90DC967BF06542E8C953B8112E1955C9589C7555F88A8
8047521334651DB422E2CF3B44D314689F534857643CC1D55D22DF7FEF1D065E
BFC65565CAA26D1FDF8E98FBB11CD5BCE558406F2F28E40D2FF79919F839F837
9A9BB689D6416CC9CE26BD93644E4C21A331D544F7A8012A82065A128D48E72C
1698D62A245FDFB7ACD82556A0D4E648240F6B8FB5C8930AC8B18A4A29777BB5
680277C3F6F6010AE948B2CFE77B104B86FDE5290A47409199DFF5EF7D8D7D99
8C3ED886220FDE5447980A1F502E5142E8FD852899B8F93F19D51209F745D54E
B054F8335F55CE93293F0DE57E9CE04DB5A7367877F8B711B3EC17AD3AA1D11C
0833D6EEBCCBA265C77D3055D6846AF811832C58D33501DA608A5A989D9FB5B3
818201648FD3241C59C9CA25CBFC0971D780D99C00F7BFD88AF285A3608A32FD
221B919032FEB5F66AA8A05849B78F8AE6B1688FF8D24296EEF6E6430D26E1DC
852083A24A76044744BC424AFAAAE132555C2897CA1EBA45535A25C922AD1FF7
B93A8D0EDEE4E5AEF187E4B79C3A3C57BBA582013494C30A922F7D0080FC2A39
5F328856E7BD5AB907813D0CE0D679D9930846B5BD558F6FBA61C95548CF5F45
CC9BDDDBFC5380531CD78DA8A17D79CDB0A26FA7826BD5CBF0C9F61B80A9020E
2132EA46587FD3895812C803FA8DAC277F3583821D40C1D6A60E60B8E13F999A
8DC745DF4D007135D3623ED3D485899E599AE1711EAC252F6AC7C0B3B32AB853
B08422AA52EB3D0DDBD752DB861D0B1DFF5FA599D67A4A3BAB2D99379066CD07
4FF6977F7A92752FB55CDFEA1B803B9E195C66844C2E93DBD608B29969CF5D55
8A33CAA9A3941614B61A4A3DA50CCF5B4ECFE34CCD0269F977B66F364269E024
3560EA5DD0DCE56FF8DE9C73EB3A28617CC86B7D11F4378713F548E73339C9C2
2D9EAC331EDB36BE642BF599F6719EAC28B6EACDAF1409D054E553DBAAA0F90F
572D47CC9245E89A8C2C3FE804305E5EEBEE1CB6BABF95CBEB4712A738B47108
41BE3AD4B3713E4288AADFCA65B157C77D6E42AAC0BECEF7C710EE672F4D3EA1
810908FD786C4BE242BDCDF8259CA101C52F7A0D2FE0CB5B5EB60B278CBEA6C7
619F7250204F12A035794FE6F939102735CEA785C6A47197666ABD2FDCE2C814
31269C6E4A2F617984E2E83E98B695577C6054000BC2B7B66F22541BC3283729
7611F3015452EE319981F27F07D1E393449D509579650E646A04FC57E1CAB90E
183B80ECAF61FDB1FA3289E256BCA22ADDB016CC3FAF3BEFE93156F23F0B977D
DE5EE8468C2F0B8EAD60047821C1809F0FAB0930956AAD16BC525B35930C2447
5B9B025AED172E9398264C1102174DE3F35EF04967EC287611A0C9662BEA42B9
B3156DD1A129222BE57F8FEA5231FC9E4298CB9EA129FB2BA282BF891B07CAA6
21493857E5878056CF8E2F4048CA7541750A5110ED0F12EE0186666F91661B72
2A021A2C978C65AA2CF962E0DEA5C4416562C7BC6A4C937E571F66D1F0F3341E
F1FF453232604F9EFB3367A7365549E193B3D601BC9A431A014F8BC5937B4D74
BB5FB94ACC38F8732B03DE5BF7F7F258155CD83E7D52E442E8A34CD71B9B9DE9
1E5A426AB9B5EA106E3828843433262D4593FA6A5BED03D63028C0AAFEA4AA59
AAEDB2E35B4C74FE4D777E0417AD7E59E35004D88ED74DC91DA2DBEAC5587192
17C32AACA8AC74BD93A6B19EDC4EAC28296DB9BE9102F9689384B4A553E7E342
09486BF3EFD0C026A07106C98514F10BB9C0E2A890495D4FB51D52B8DAF0F445
E02B2FA6A8D35E94282B3929BCBA0D2CDC7970AF0BCC80BB64F34C4D4BB7ECF5
DFE24EB96ABE2D8900684EF3D347876293A1ADE89C582898CDA3AD586242A955
D68A530698BA6E50BBEED01B284C5CC10887350DBBB3E7A3C7A14CF7BC731E99
6F431C318824FC3BCA91DF797A26F5E1C3DA809F9529595AD196ECB1643FB127
16A0872C8F68D03B64D57C598C670C6554C3C509E363007FB213BEE350804794
A3CB0C283E511286D8C3D3787493BE05736CA382BEA56E3EF92C7433EE55C4EE
E667C9416EA4FB87B4A4D21B78B775FFDC93E4FC2D2DEF283E617C4E9E9BC680
63842F51B857A81E3A69B687EB8F74C52CC9911F7BFB0DC1E8AE5B0EF2861766
A6255FC3178918604B9642F4B1C7650631FCE5C214CE0D596D295F848D6C97F8
B2AB840FAD98E2E3A19E222F2F4C9561291B010AF48700B780EBE4B0E478768B
A86963EB2D84C00BF2DCF775608BA9CCC2020107EEAF46490546598B1382AA53
EFAE26EA9690AEAC0258A64C3EEFE5CFAA41620EB4D1637F9AE60832DE009B6D
57E11AB564A93AC9CA3E91AAAC9FC5E71BDADC1E5ABE8CB478CC6B259C8AE7F0
B94C9085B97D74A2910DABEB32B00C220690B60A903D291F4FDD9EDEE7EE2563
F6550C5675BC7789D0FCB3578A86FD02FBFB3F45AF03F004B65B0209276D72E6
5D6FFCC2C2D56AB22553001E8333D79ABE00CAEFC9FA5F5E94B9DA4232E018E4
027E786DB51FCD69EB288E71B51B3BA5EB472C8EDEC227F2BC6CDDFC00D98E34
5EBBFBC3A252E630D347CB3CDACF1B88468B69677F2463F7D6050CE676F06EE0
CD9715CF9C6A89DAA84D6628BEC6803796A28C53598EF6B2D41ABEDD9EF27583
5E8856E8DDC6C20F1DDE902B5A9DE78C570A583C2F98E0305E4CF6E7910F2BEB
9593424FB4A58D0F1919AD3A13FA281591873D92BA5A04E12A22AA9429CCD6F4
BDEC028715272A329D9115A2BD7F04CEEC32B78372E74A8C3086859C8D5D6777
01882F91D1E51BCDE1D62CFE5092E964AAFEF97D79AC910C6EC8950B70BC01C7
A2041B4AE823CB74464DFF46AE9E2ADACBAB9737D011CCE9F0EACE9F97B09110
5AF67EE7BE0E1B393FDB13FC3B3968DD6F387D011A5E573EDEBE343BFEB7CC1E
4B69B0857BFC16F30531FFC2D3463B8204E5500C69B21715F5B8AEEAFB7F8644
983D6B561E4E80965E218995F1A0E73A6DE96CED0AF66DF64C752CBA71B573BA
C93A9F5B0879F2CAD3B9DAE1AF69D7079040BB1134C2B829E7A3F6E9BF5FE139
15A6EF4DF74DA62A849BA59F70939ADE4894BF36A317DAE8B934A324D00985FC
7AB9D41A8069B91C4F4D85A5506B8A25F7B210205A57438F430957F8749B9B1D
4DF80C4D8ECA4318D681BF6AF015367A8CB272680B488ECE13872598D436AA8D
EE050F18B56AC917E2B532439B1089EA78D73B3743364B167091699C2115A73D
0B55D340264F6F62668E613D633C6B8EB35BF353DE182349D5E0D65A0D6A9CF3
2EBA7C819206027739C55AF2C3D40C230D4C2B02A658EFC0758386E8C5C1C1EF
6519425204F3689193B5B5DCCD3BD771BAD8B5578DE45CB9AF0DD6EABFE0B792
C12212D4702588E0CDD150336244C78F84794BC06EBF9762E6C89C751ADDC185
62369F11629C721BB4C34B83DC7422432F66EB5169B3C3C8FD5D1D3110AAE19C
F9CD0D564AAB69995B4A5CBC4A617F5993FBDD7BDB152D47D46118AE6C941742
749F9FFAC11DD3C57FEA66E666508DDC512CBD7FB773AF63F8C1135C16625B11
50DCA52CAAE6F94113201F5C21BE3ABA5FC6C613CAFFD6A8435D9837E0A79581
E214F331E4E94D282342075C4E2E5F2C246A3E0118048EE2726EC4C35EFE2601
4D7DA6AAC6295EAC559E3791DFE91D193EA08ECDE17B002CB066896264EA3C89
2048AE9D28A8BDE600F2C80E15D099DEF6A6E0C461CC686528944FB9128DABC1
F8FF8F77356E9E7DF67268453D02548E3EE90269B3AF632597CA8F58D30AD7C0
CE05E4D84233BD1A886DB1A132D0D83E44DF0C471681F10493ABF33A873D8E44
4C4699ECA285566A371F088DEC104C0684644C3B434F1B8797F78CF9B51D58A9
139EA67C0D93F20423654342EC98BE07F35ACA5F5F0FEAB66E85FC708088D28E
1196CFEDD4AFE461B96DAAC5F13B9B61DF210FBA8F0A049F9218AF8A8CC2BA3C
C7081BEEDB98B2E858C49E13871BFB84CF4E29EF5CE0A145186B2292FB58D7A3
843E45F077EF4A0C73C57754E7A30DAB28BB8EEE73CDA1D80CEEAEAD9D759572
58B138788D1B06ACE449404ACC43F0B2EAEC2793A05CBBC7C0517A759F653CEC
372FE0B24F065E6A31DA62E746BBE36D8388702FAD967C8C8D3B6CD63D1F1938
1D6EDBA1E403E1CCEAC873D9C64C4CDD0CB2E0CCD0F87458AE8BCA59AAC1E9F5
E65447AE58639F7D86B4F29AB4BD2FCDD3F1463EDE02194285A658014C6F24DC
42EBAA3F4884202E17FD47022B96FA0D299D08FFCD4F82236E0BD669734E5A3F
E2182B6E6DF14ACBAFEB9B4E599E9219FC6132D26064A8F25523C1B82A68B969
72889E7BB994BF3175F8EE4E2C1C8EA5AB9EFEE51CCEA4E8E136A1EE5E7174D9
515C1424E7C5D7EA85A2E2E07AF77482E0EB11C288C00124FDB67741C1FF8867
CB09ECF1D42FAA0865D4288E431C29D49F26F155ECA037A3736EEBEEF570D0B4
6516369324EFE397AEEB94DFC4C1B1BB82525BAA3F9BFECB4589931998C4C31C
C82D3AFE73A17DBBB58814E91CDD8AA5D7A6204F3AF9E4BEB42F777B111544E9
E6E88C9D8BB749FEAFE2230F919F5FFB5D4F1D3C8D213AD8AFB26F26047E4BC9
75D3B6EA379A46508CE194BE5DEF0607C66119DEE935A3851E768AF9406FF8A2
173D6B4AC4DFED2E204113F539376825CBF4FCAA747F2494DB145AE6208367F5
10B642EFD7D2ED4176A7C7B8DC8732BF800DFAF9C7680D8EA06DCD5C23DA9BAA
095BE71D821D6690CF56EE99704736ACDCDBB82C5A450DA73543114F54D73B0A
B6CC688A72D192282F0405BF1072C5FD488CFE49193976079DEA725ECA0EEF50
04CC5D28E524880BA664BFE4FDA3E3AFEB4226A0473E60B865F598E450CBEEC6
838DEC3D0033BC57F17CBFA14632FA38E87887E0A12313BCE012A8CE3A8649F4
4F2367664F95A98980A67666AF75E154B613DBF1AEA3C5A2FC2BF1381A01BE8D
A09FC9D79CDC69276DB47116D355E4562926636E04D62763F181B5E25DB4E537
6CC7D6E5B2FC224814D492BDE81E67AC3D0DF805E34469F53788810EF3F8EDCD
BCD3BA8481D5ACEA3856E91FE1575136A391CA7B33C50D0C4D7C9CF44BC7C1A3
BB755170B0B8ED44AF85727C751D766BF4870056B7E67AC5351A6124A9098266
7C26ECE4E534A41705E473B5A93B4A5828129F2F4B141149B21DC20EBCF8631C
1FCF8081C59387D3AF21A8870927FAD4EB5716E4318AAFD637196253923FF5FF
14D26597A77DF0273E41D5E2BCA1E39F59BC77B7C0C0AE7067744A40273D80AF
FCB84E10F0A7EDA1156FE5E363AA76ECDEBF043BED48AA5A729927BE688D664A
77C814850B72E6A007B5FCF180CDB6F95EF84BFAC096A482710FD43C89F849F0
0732840EE22F7B5718FAB6AE7D588696A91A100247B59EEC070301E277C2E40C
F562C071D014FEF789886AF060652088134D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 13271151 7085785 1000 600 600 (figura_3.dvi)
@start /Fa 133[39 41 47 120[{}3 83.022 /CMMI10 rf /Fb
12[42 127[33 2[46 3[23 2[23 3[37 46 30[56 69[{ T1Encoding ReEncodeFont }
8 83.022 /SFRM1000 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-600 -600 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -600 -600 a -600
-600 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -600 -600 a
%%HiResBoundingBox: 0 0 202.50172pt 108.1205pt
 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -9 -175 a
tx@Dict begin { 0.0 -51.21501 } PutCoor PutBegin  end
 -9 -175 a -174
-154 a Fb(Elips\363ide)-9 -175 y
tx@Dict begin  PutEnd  end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@O 10 {InitPnode } /NodeScale {} def NewNode end  end

-9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@X 10 {InitPnode } /NodeScale {} def NewNode end  end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@Y 10 {InitPnode } /NodeScale {} def NewNode end  end
 -9 -175 a -9
-175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@Z 10 {InitPnode } /NodeScale {} def NewNode end  end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
4 0 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@X' 10 {InitPnode } /NodeScale {} def NewNode end 
end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 3 0 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@Y' 10 {InitPnode } /NodeScale {} def NewNode end 
end
 -9 -175
a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 2 3dto2d cm_1 exch cm_1 exch end  28.45274 mul exch 28.45274 mul
exch  } false /N@Z' 10 {InitPnode } /NodeScale {} def NewNode end 
end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
4 5.0 28.45274 div add 0  0 3dto2d cm_1 exch cm_1 exch end  28.45274
mul exch 28.45274 mul exch  } false /N@Xname 10 {InitPnode } /NodeScale
{} def NewNode end  end
 -9 -175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0  3 5.0 28.45274 div add  0 3dto2d cm_1 exch cm_1 exch end  28.45274
mul exch 28.45274 mul exch  } false /N@Yname 10 {InitPnode } /NodeScale
{} def NewNode end  end
 -9
-175 a -9 -175 a
tx@Dict begin  tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {28.45274 } def /decal -2 def /viewpointXYZ { 20 20 10}
def /Decran 15 def /RotX 0 def /RotY 0 def /RotZ 0 def /RotSequence
(xyz) def RotSequence (xyz) eq RotSequence (xzy) eq or RotSequence
(yxz) eq or RotSequence (yzx) eq or RotSequence (zxy) eq or RotSequence
(zyx) eq or {} { /RotSequence (xyz) def } ifelse /fontsize 10  28.45274
mul 28.45 div def /projectionsifacevisible true def /R 4 def /r1 4
def /r0 1.5 def 36 setresolution /phi 0  def /theta 90  def /r 2 def
/a 4 def /b a def /c a  def /h 6 def /trunccoeff .25 def /chanfreincoeff
.8 def /affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype
-1 def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg }
def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def
/solidintersectioncolor [ (rouge)] def /solidintersectionplan [ [0
0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition () def
/args { } def /Mode 2 def /lightintensity 2 def /tablez [] def /zcolor
[] def /solidlinewidth {0.8 } def /linecolor {0 0 1  setrgbcolor }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0  0  2 5.0 28.45274 div add 3dto2d cm_1 exch cm_1 exch end  28.45274
mul exch 28.45274 mul exch  } false /N@Zname 10 {InitPnode } /NodeScale
{} def NewNode end  end
 -9 -175 a @beginspecial @setspecial
  tx@Dict begin STP newpath    1. .setopacityalpha  1 setlinejoin 
/PSfont {/Times-Roman } def /pst@fill { 1. .setopacityalpha fill }
def /strokeopacity 1. def /fillopacity 1. def /xunit {28.45274 } def
/decal -2 def /viewpointXYZ { 20 20 10} def /Decran 15 def /RotX 0
def /RotY 0 def /RotZ 0 def /RotSequence (xyz) def RotSequence (xyz)
eq RotSequence (xzy) eq or RotSequence (yxz) eq or RotSequence (yzx)
eq or RotSequence (zxy) eq or RotSequence (zyx) eq or {} { /RotSequence
(xyz) def } ifelse /fontsize 10  28.45274 mul 28.45 div def /projectionsifacevisible
true def /R 4 def /r1 4 def /r0 1.5 def 36 setresolution /phi 0  def
/theta 90  def /r 2 def /a 4 def /b a def /c a  def /h 6 def /trunccoeff
.25 def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff
1 def /solidintersectiontype -1 def /section {R h 2 div neg R h 2 div
r h 2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  28.45274 mul 28.45 div } bind def /lightsrc {20 10 5} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0 } def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 /CZ exch def /CY exch def /CX exch def /esfera { 3 dict begin
/v exch def /u exch def mark 3 u Sin v Cos mul mul 2 u Sin v Sin mul
mul 1.5 u Cos mul gere_pst-deffunction end } def  end      1. .setopacityalpha
 1 setlinejoin  /PSfont {/Times-Roman } def /pst@fill { 1. .setopacityalpha
fill } def /strokeopacity 1. def /fillopacity 1. def /xunit {28.45274
} def /decal -2 def /viewpointXYZ { 20 20 10} def /Decran 15 def /RotX
0 def /RotY 0 def /RotZ 0 def /RotSequence (xyz) def RotSequence (xyz)
eq RotSequence (xzy) eq or RotSequence (yxz) eq or RotSequence (yzx)
eq or RotSequence (zxy) eq or RotSequence (zyx) eq or {} { /RotSequence
(xyz) def } ifelse /fontsize 10  28.45274 mul 28.45 div def /projectionsifacevisible
true def /R 4 def /r1 4 def /r0 1.5 def 36 setresolution /phi 0  def
/theta 90  def /r 2 def /a 4 def /b a def /c a  def /h 6 def /trunccoeff
.25 def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff
1 def /solidintersectiontype -1 def /section {R h 2 div neg R h 2 div
r h 2 div r h 2 div neg } def /base [ 0 4 0 2 pi mul] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /function (esfera)
def /definition () def /args { } def /Mode 2 def /lightintensity 2
def /tablez [] def /zcolor [] def /solidlinewidth {0.4 } def /linecolor
{0  setgray } def /linestyle {solid} def /fillcolor {0 0 0.5 0  setcmykcolor
currentrgbcolor} def /fillincolor {0.5 1 0.5  setrgbcolor currentrgbcolor}
def /color1 {1 0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor
} def /color3 {0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor
} def /range [ -5 5] def /action (draw**) def /texte () def /pos (cc)
def /proj-fontsize {10  28.45274 mul 28.45 div } bind def /lightsrc
{20 10 5} def /rmfaces [] def /fcol [] def /solidhue [] def /solidinouthue
[] def /solidinhue [] def /origin {0 0 0 } def /sommets [] def /faces
[] def /solidshow [] def /solidnum [] def SolidesDict begin /solidnumsep
15.0  def end /solidnumf [] def /solidtrunc [] def /solidaffinage []
def /ngrid [30 30] def /isolatin true def /affinagerm true def /chanfrein
false def /solidgrid true def /solidplanmarks false def /solidplangrid
false def /solidshowbase3d false def /activationgestioncouleurs true
def /solidshowbase false def /soliddualreg false def /solidgeode false
def /solidhollow false def /solidbiface true def viewpointXYZ /ZpointVue
ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue atan} bind
def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul add sqrt atan}
bind def /Dobs {XpointVue dup mul YpointVue dup mul add ZpointVue dup
mul add sqrt} bind def XpointVue YpointVue ZpointVue /viewpoint defpoint3d
 SolidesDict begin  0. 0. 0.  /CZ exch def /CY exch def /CX exch def
pst-surfaceparametree end   /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0 0 1  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict
/N@X known { /N@X load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
 /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   0  setlinecap [ 
5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0 0 1  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict
/N@Y known { /N@Y load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
 /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   0  setlinecap [ 
5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0 0 1  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict
/N@Z known { /N@Z load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
 /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   0  setlinecap [ 
5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0 0 1  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [
tx@NodeDict begin tx@NodeDict /N@X' known { /N@X' load GetCenter }
{ 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@X known { /N@X
load GetCenter } { 0 0 } ifelse end   /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0 0 1  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [
tx@NodeDict begin tx@NodeDict /N@Y' known { /N@Y' load GetCenter }
{ 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Y known { /N@Y
load GetCenter } { 0 0 } ifelse end   /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0 0 1  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [
tx@NodeDict begin tx@NodeDict /N@Z' known { /N@Z' load GetCenter }
{ 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Z known { /N@Z
load GetCenter } { 0 0 } ifelse end   /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0 0 1  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial -9 -175 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Xname known { /N@Xname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 -9 -175 a -33 -157
a Fa(x)-9 -175 y
tx@Dict begin  PutEnd  end
 -9 -175 a -9 -175 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Yname known { /N@Yname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 -9 -175 a -31 -165
a Fa(y)-9 -175 y
tx@Dict begin  PutEnd  end
 -9 -175 a -9 -175 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Zname known { /N@Zname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 -9 -175 a -30 -157
a Fa(z)-9 -175 y
tx@Dict begin  PutEnd  end
 -9 -175 a @beginspecial @setspecial
  tx@Dict begin STP newpath end


@endspecial 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
